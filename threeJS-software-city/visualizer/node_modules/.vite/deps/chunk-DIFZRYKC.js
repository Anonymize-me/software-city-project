import {
  getNodesKeys,
  getValueFromType,
  getValueType
} from "./chunk-4KORGJVV.js";
import {
  MathUtils,
  Vector3
} from "./chunk-MCRSFNJN.js";
import {
  __publicField
} from "./chunk-XNHBATJA.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  Vertex: "vertex",
  Fragment: "fragment"
};
var NodeUpdateType = {
  None: "none",
  Frame: "frame",
  Object: "object"
};

// node_modules/three/examples/jsm/nodes/core/Node.js
var _nodeId = 0;
var Node = class {
  constructor(nodeType = null) {
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.None;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  get type() {
    return this.constructor.name;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getNodeType() {
    return this.nodeType;
  }
  update() {
    console.warn("Abstract function.");
  }
  generate() {
    console.warn("Abstract function.");
  }
  analyze(builder) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.analyze(builder);
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    const nodeKeys = getNodesKeys(this);
    for (const property2 of nodeKeys) {
      this[property2].analyze(builder);
    }
  }
  build(builder, output = null) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addStack(this);
    const nodeData = builder.getDataFromNode(this);
    const isGenerateOnce = this.generate.length === 1;
    let snippet = null;
    if (isGenerateOnce) {
      const type = this.getNodeType(builder);
      snippet = nodeData.snippet;
      if (snippet === void 0) {
        snippet = this.generate(builder) || "";
        nodeData.snippet = snippet;
      }
      snippet = builder.format(snippet, type, output);
    } else {
      snippet = this.generate(builder, output) || "";
    }
    builder.removeStack(this);
    return snippet;
  }
  serialize(json) {
    const nodeKeys = getNodesKeys(this);
    if (nodeKeys.length > 0) {
      const inputNodes = {};
      for (const property2 of nodeKeys) {
        inputNodes[property2] = this[property2].toJSON(json.meta).uuid;
      }
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        const uuid = json.inputNodes[property2];
        this[property2] = nodes[uuid];
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.5,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
Node.prototype.isNode = true;
var Node_default = Node;

// node_modules/three/examples/jsm/nodes/core/VaryNode.js
var VaryNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const node = this.node;
    const name = this.name;
    const nodeVary = builder.getVaryFromNode(this, type);
    if (name !== null) {
      nodeVary.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVary, NodeShaderStage.Vertex);
    builder.flowNodeFromShaderStage(NodeShaderStage.Vertex, node, type, propertyName);
    return builder.getPropertyName(nodeVary);
  }
};
var VaryNode_default = VaryNode;

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attribute2 = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));
    if (builder.isShaderStage("vertex")) {
      return attribute2.name;
    } else {
      const nodeVary = new VaryNode_default(this);
      return nodeVary.build(builder, attribute2.type);
    }
  }
};
var AttributeNode_default = AttributeNode;

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
BypassNode.prototype.isBypassNode = true;
var BypassNode_default = BypassNode;

// node_modules/three/examples/jsm/nodes/core/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", nodeType = "code") {
    super(nodeType);
    this.code = code2;
    this._includes = [];
  }
  setIncludes(includes) {
    this._includes = includes;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
};
CodeNode.prototype.isCodeNode = true;
var CodeNode_default = CodeNode;

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
ContextNode.prototype.isContextNode = true;
var ContextNode_default = ContextNode;

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
  }
  build(builder, output) {
    const type = builder.getVectorType(this.getNodeType(builder, output));
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.propertyName !== void 0) {
      return builder.format(nodeData.propertyName, type, output);
    } else if (builder.context.temp !== false && type !== "void " && output !== "void" && nodeData.dependenciesCount > 1) {
      const snippet = super.build(builder, type);
      const nodeVar = builder.getVarFromNode(this, type);
      const propertyName = builder.getPropertyName(nodeVar);
      builder.addFlowCode(`${propertyName} = ${snippet}`);
      nodeData.snippet = snippet;
      nodeData.propertyName = propertyName;
      return builder.format(nodeData.propertyName, type, output);
    }
    return super.build(builder, output);
  }
};
TempNode.prototype.isTempNode = true;
var TempNode_default = TempNode;

// node_modules/three/examples/jsm/nodes/core/ExpressionNode.js
var ExpressionNode = class extends TempNode_default {
  constructor(snipped = "", nodeType = "void") {
    super(nodeType);
    this.snipped = snipped;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const snipped = this.snipped;
    if (type === "void") {
      builder.addFlowCode(snipped);
    } else {
      return `( ${snipped} )`;
    }
  }
};
var ExpressionNode_default = ExpressionNode;

// node_modules/three/examples/jsm/nodes/core/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    for (const inputNode of inputs) {
      const node = parameters[inputNode.name];
      if (node !== void 0) {
        params.push(node.build(builder, inputNode.type));
      } else {
        throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;

// node_modules/three/examples/jsm/nodes/core/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "") {
    super(code2);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  call(parameters = {}) {
    return new FunctionCallNode_default(this, parameters);
  }
  generate(builder, output) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2;
    if (output === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output);
    }
  }
};
var FunctionNode_default = FunctionNode;

// node_modules/three/examples/jsm/nodes/core/InstanceIndexNode.js
var InstanceIndexNode = class extends Node_default {
  constructor() {
    super("uint");
  }
  generate(builder) {
    return builder.getInstanceIndex();
  }
};
InstanceIndexNode.prototype.isInstanceIndexNode = true;
var InstanceIndexNode_default = InstanceIndexNode;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(name = null, nodeType = "vec4") {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.value = value;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  serialize(data) {
    var _a, _b;
    super.serialize(data);
    data.value = ((_b = (_a = this.value) == null ? void 0 : _a.toArray) == null ? void 0 : _b.call(_a)) || this.value;
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
  }
  deserialize(data) {
    var _a, _b;
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = getValueFromType(data.valueType);
    this.value = ((_b = (_a = this.value) == null ? void 0 : _a.fromArray) == null ? void 0 : _b.call(_a, data.value)) || data.value;
  }
  generate() {
    console.warn("Abstract function.");
  }
};
InputNode.prototype.isInputNode = true;
var InputNode_default = InputNode;

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type, output);
  }
};
UniformNode.prototype.isUniformNode = true;
var UniformNode_default = UniformNode;

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class _OperatorNode extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new _OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return "int";
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = builder.getTypeLength(output);
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addFlowCode(`${a} ${this.op} ${b}`);
        return a;
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a} ${this.op} ${b}`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  op(op, ...params) {
    this.node = new OperatorNode_default(op, this.node, ...params);
    return this;
  }
  assign(...params) {
    return this.op("=", ...params);
  }
  add(...params) {
    return this.op("+", ...params);
  }
  sub(...params) {
    return this.op("-", ...params);
  }
  mul(...params) {
    return this.op("*", ...params);
  }
  div(...params) {
    return this.op("/", ...params);
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const node = this.node;
    if (node.isTempNode === true) {
      return node.build(builder);
    }
    const name = this.name;
    const type = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, type);
    const nodeVar = builder.getVarFromNode(this, type);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
BufferNode.prototype.isBufferNode = true;
var BufferNode_default = BufferNode;

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var _Object3DNode = class _Object3DNode extends Node_default {
  constructor(scope = _Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.Object;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d !== null ? this.object3d : frame.object;
    const uniformNode = this._uniformNode;
    const camera = frame.camera;
    const scope = this.scope;
    if (scope === _Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION) {
      this._uniformNode.nodeType = "vec3";
      this._uniformNode.value = new Vector3();
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_Object3DNode, "VIEW_MATRIX", "viewMatrix");
__publicField(_Object3DNode, "NORMAL_MATRIX", "normalMatrix");
__publicField(_Object3DNode, "WORLD_MATRIX", "worldMatrix");
__publicField(_Object3DNode, "POSITION", "position");
__publicField(_Object3DNode, "VIEW_POSITION", "viewPosition");
var Object3DNode = _Object3DNode;
var Object3DNode_default = Object3DNode;

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var _CameraNode = class _CameraNode extends Object3DNode_default {
  constructor(scope = _CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === _CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
__publicField(_CameraNode, "PROJECTION_MATRIX", "projectionMatrix");
var CameraNode = _CameraNode;
var CameraNode_default = CameraNode;

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.Object;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    this.node = new UniformNode_default(null, uniformType);
    this.nodeType = uniformType;
    if (uniformType === "color") {
      this.nodeType = "vec3";
    } else if (uniformType === "texture") {
      this.nodeType = "vec4";
    }
  }
  getNodeType() {
    return this.uniformType;
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const value = object[this.property];
    this.node.value = value;
  }
  generate(builder) {
    return this.node.build(builder, this.getNodeType(builder));
  }
};
var ReferenceNode_default = ReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var _MaterialNode = class _MaterialNode extends Node_default {
  constructor(scope = _MaterialNode.COLOR) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === _MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === _MaterialNode.OPACITY) {
      return "float";
    } else if (scope === _MaterialNode.SPECULAR) {
      return "vec3";
    } else if (scope === _MaterialNode.ROUGHNESS || scope === _MaterialNode.METALNESS) {
      return "float";
    }
  }
  generate(builder, output) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.ALPHA_TEST) {
      node = new MaterialReferenceNode_default("alphaTest", "float");
    } else if (scope === _MaterialNode.COLOR) {
      const colorNode = new MaterialReferenceNode_default("color", "color");
      if (material.map !== null && material.map !== void 0 && material.map.isTexture === true) {
        node = new OperatorNode_default("*", colorNode, new MaterialReferenceNode_default("map", "texture"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = new MaterialReferenceNode_default("opacity", "float");
      if (material.alphaMap !== null && material.alphaMap !== void 0 && material.alphaMap.isTexture === true) {
        node = new OperatorNode_default("*", opacityNode, new MaterialReferenceNode_default("alphaMap", "texture"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR) {
      const specularColorNode = new MaterialReferenceNode_default("specularColor", "color");
      if (material.specularColorMap !== null && material.specularColorMap !== void 0 && material.specularColorMap.isTexture === true) {
        node = new OperatorNode_default("*", specularColorNode, new MaterialReferenceNode_default("specularColorMap", "texture"));
      } else {
        node = specularColorNode;
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode_default(scope, outputType);
    }
    return node.build(builder, output);
  }
};
__publicField(_MaterialNode, "ALPHA_TEST", "alphaTest");
__publicField(_MaterialNode, "COLOR", "color");
__publicField(_MaterialNode, "OPACITY", "opacity");
__publicField(_MaterialNode, "SPECULAR", "specular");
__publicField(_MaterialNode, "ROUGHNESS", "roughness");
__publicField(_MaterialNode, "METALNESS", "metalness");
var MaterialNode = _MaterialNode;
var MaterialNode_default = MaterialNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class _ModelNode extends Object3DNode_default {
  constructor(scope = _ModelNode.VIEW_MATRIX) {
    super(scope);
  }
};
var ModelNode_default = ModelNode;

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends Node_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (let i = 0; i < nodes.length; i++) {
      const input = nodes[i];
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    return `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
  }
};
var JoinNode_default = JoinNode;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.name = name;
    this.type = type;
    this.node = node;
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
NodeUniform.prototype.isNodeUniform = true;

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};
NodeAttribute.prototype.isNodeAttribute = true;

// node_modules/three/examples/jsm/nodes/core/NodeVary.js
var NodeVary = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};
NodeVary.prototype.isNodeVary = true;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};
NodeVar.prototype.isNodeVar = true;

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var defaultShaderStages = ["fragment", "vertex"];
var shaderStages = [...defaultShaderStages, "compute"];
var vector = ["x", "y", "z", "w"];
var typeFromLength = /* @__PURE__ */ new Map();
typeFromLength.set(1, "float");
typeFromLength.set(2, "vec2");
typeFromLength.set(3, "vec3");
typeFromLength.set(4, "vec4");
typeFromLength.set(9, "mat3");
typeFromLength.set(16, "mat4");

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type);
      return `${nodeSnippet}.${this.components}`;
    } else {
      return node.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var _MathNode = class _MathNode extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (isWebGL && (method === _MathNode.DFDX || method === _MathNode.DFDY) && output === "vec3") {
      return new JoinNode_default([
        new _MathNode(method, new SplitNode_default(a, "x")),
        new _MathNode(method, new SplitNode_default(a, "y")),
        new _MathNode(method, new SplitNode_default(a, "z"))
      ]).build(builder);
    } else if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode_default(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode_default(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode_default(new OperatorNode_default("*", tA, tB), "xyz");
      return new _MathNode(_MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === _MathNode.SATURATE) {
      return builder.format(`clamp( ${a.build(builder, inputType)}, 0.0, 1.0 )`, type, output);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( -" + a.build(builder, inputType) + " )", type, output);
    } else if (method === _MathNode.INVERT) {
      return builder.format("( 1.0 - " + a.build(builder, inputType) + " )", type, output);
    } else {
      const params = [];
      if (method === _MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (c !== null) {
          params.push(b.build(builder, inputType), c.build(builder, inputType));
        } else if (b !== null) {
          params.push(b.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
// 1 input
__publicField(_MathNode, "RADIANS", "radians");
__publicField(_MathNode, "DEGREES", "degrees");
__publicField(_MathNode, "EXP", "exp");
__publicField(_MathNode, "EXP2", "exp2");
__publicField(_MathNode, "LOG", "log");
__publicField(_MathNode, "LOG2", "log2");
__publicField(_MathNode, "SQRT", "sqrt");
__publicField(_MathNode, "INVERSE_SQRT", "inversesqrt");
__publicField(_MathNode, "FLOOR", "floor");
__publicField(_MathNode, "CEIL", "ceil");
__publicField(_MathNode, "NORMALIZE", "normalize");
__publicField(_MathNode, "FRACT", "fract");
__publicField(_MathNode, "SIN", "sin");
__publicField(_MathNode, "COS", "cos");
__publicField(_MathNode, "TAN", "tan");
__publicField(_MathNode, "ASIN", "asin");
__publicField(_MathNode, "ACOS", "acos");
__publicField(_MathNode, "ATAN", "atan");
__publicField(_MathNode, "ABS", "abs");
__publicField(_MathNode, "SIGN", "sign");
__publicField(_MathNode, "LENGTH", "length");
__publicField(_MathNode, "NEGATE", "negate");
__publicField(_MathNode, "INVERT", "invert");
__publicField(_MathNode, "DFDX", "dFdx");
__publicField(_MathNode, "DFDY", "dFdy");
__publicField(_MathNode, "SATURATE", "saturate");
__publicField(_MathNode, "ROUND", "round");
// 2 inputs
__publicField(_MathNode, "MIN", "min");
__publicField(_MathNode, "MAX", "max");
__publicField(_MathNode, "MOD", "mod");
__publicField(_MathNode, "STEP", "step");
__publicField(_MathNode, "REFLECT", "reflect");
__publicField(_MathNode, "DISTANCE", "distance");
__publicField(_MathNode, "DOT", "dot");
__publicField(_MathNode, "CROSS", "cross");
__publicField(_MathNode, "POW", "pow");
__publicField(_MathNode, "TRANSFORM_DIRECTION", "transformDirection");
// 3 inputs
__publicField(_MathNode, "MIX", "mix");
__publicField(_MathNode, "CLAMP", "clamp");
__publicField(_MathNode, "REFRACT", "refract");
__publicField(_MathNode, "SMOOTHSTEP", "smoothstep");
__publicField(_MathNode, "FACEFORWARD", "faceforward");
var MathNode = _MathNode;
var MathNode_default = MathNode;

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var _PositionNode = class _PositionNode extends Node_default {
  constructor(scope = _PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _PositionNode.GEOMETRY) {
      outputNode = new AttributeNode_default("position", "vec3");
    } else if (scope === _PositionNode.LOCAL) {
      outputNode = new VaryNode_default(new _PositionNode(_PositionNode.GEOMETRY));
    } else if (scope === _PositionNode.WORLD) {
      const vertexPositionNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new ModelNode_default(ModelNode_default.WORLD_MATRIX), new _PositionNode(_PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW) {
      const vertexPositionNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new _PositionNode(_PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new _PositionNode(_PositionNode.VIEW));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_PositionNode, "GEOMETRY", "geometry");
__publicField(_PositionNode, "LOCAL", "local");
__publicField(_PositionNode, "WORLD", "world");
__publicField(_PositionNode, "VIEW", "view");
__publicField(_PositionNode, "VIEW_DIRECTION", "viewDirection");
var PositionNode = _PositionNode;
var PositionNode_default = PositionNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends Node_default {
  constructor(position2 = new PositionNode_default()) {
    super("vec4");
    this.position = position2;
  }
  generate(builder) {
    const position2 = this.position;
    const mvpMatrix = new OperatorNode_default("*", new CameraNode_default(CameraNode_default.PROJECTION_MATRIX), new ModelNode_default(ModelNode_default.VIEW_MATRIX));
    const mvpNode = new OperatorNode_default("*", mvpMatrix, position2);
    return mvpNode.build(builder);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var _NormalNode = class _NormalNode extends Node_default {
  constructor(scope = _NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _NormalNode.GEOMETRY) {
      outputNode = new AttributeNode_default("normal", "vec3");
    } else if (scope === _NormalNode.LOCAL) {
      outputNode = new VaryNode_default(new _NormalNode(_NormalNode.GEOMETRY));
    } else if (scope === _NormalNode.VIEW) {
      const vertexNormalNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.NORMAL_MATRIX), new _NormalNode(_NormalNode.LOCAL));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    } else if (scope === _NormalNode.WORLD) {
      const vertexNormalNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new _NormalNode(_NormalNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_NormalNode, "GEOMETRY", "geometry");
__publicField(_NormalNode, "LOCAL", "local");
__publicField(_NormalNode, "WORLD", "world");
__publicField(_NormalNode, "VIEW", "view");
var NormalNode = _NormalNode;
var NormalNode_default = NormalNode;

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
PointUVNode.prototype.isPointUVNode = true;
var PointUVNode_default = PointUVNode;

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
  }
  getInputType() {
    return "storageBuffer";
  }
};
StorageBufferNode.prototype.isStorageBufferNode = true;
var StorageBufferNode_default = StorageBufferNode;

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
UVNode.prototype.isUVNode = true;
var UVNode_default = UVNode;

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = new UVNode_default(), biasNode = null) {
    super(value, "vec4");
    this.uvNode = uvNode;
    this.biasNode = biasNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getInputType() {
    return "texture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "texture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec2");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
TextureNode.prototype.isTextureNode = true;
var TextureNode_default = TextureNode;

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
  }
  generate(builder) {
    return builder.getFrontFacing();
  }
};
FrontFacingNode.prototype.isFrontFacingNode = true;
var FrontFacingNode_default = FrontFacingNode;

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.updateType = NodeUpdateType.Object;
    this.updateDispatchCount();
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  update({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addFlowCode(snippet);
      }
    }
  }
};
ComputeNode.prototype.isComputeNode = true;
var ComputeNode_default = ComputeNode;

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    const elseType = this.elseNode.getNodeType(builder);
    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
      return elseType;
    }
    return ifType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const context2 = { temp: false };
    const nodeProperty = new PropertyNode_default(null, type).build(builder);
    const nodeSnippet = new ContextNode_default(
      this.condNode
      /*, context*/
    ).build(builder, "bool"), ifSnippet = new ContextNode_default(this.ifNode, context2).build(builder, type), elseSnippet = new ContextNode_default(this.elseNode, context2).build(builder, type);
    builder.addFlowCode(`if ( ${nodeSnippet} ) {

		${nodeProperty} = ${ifSnippet};

	} else {

		${nodeProperty} = ${elseSnippet};

	}`);
    return nodeProperty;
  }
};
var CondNode_default = CondNode;

// node_modules/three/examples/jsm/nodes/lights/ReflectedLightNode.js
var ReflectedLightNode = class extends Node_default {
  constructor() {
    super("vec3");
    this.directDiffuse = new VarNode_default(new UniformNode_default(new Vector3()), "DirectDiffuse");
    this.directSpecular = new VarNode_default(new UniformNode_default(new Vector3()), "DirectSpecular");
    this.indirectDiffuse = new VarNode_default(new UniformNode_default(new Vector3()), "IndirectDiffuse");
    this.indirectSpecular = new VarNode_default(new UniformNode_default(new Vector3()), "IndirectSpecular");
  }
  generate(builder) {
    const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = this;
    const totalLight = new OperatorNode_default("+", directDiffuse, directSpecular, indirectDiffuse, indirectSpecular);
    return totalLight.build(builder);
  }
};
var ReflectedLightNode_default = ReflectedLightNode;

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType() {
    return this.convertTo;
  }
  generate(builder) {
    const convertTo = this.convertTo;
    const node = this.node;
    if (builder.isReference(convertTo) === false) {
      const nodeSnippet = node.build(builder, convertTo);
      return builder.format(nodeSnippet, this.getNodeType(builder), convertTo);
    } else {
      return node.build(builder, convertTo);
    }
  }
};
var ConvertNode_default = ConvertNode;

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output);
  }
};
ConstNode.prototype.isConstNode = true;
var ConstNode_default = ConstNode;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var shaderNodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get: function(node, prop) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return nodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(node, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return node[prop];
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj) {
  const type = typeof obj;
  if (type === "number" || type === "boolean") {
    return nodeObject(getAutoTypedConstNode(obj));
  } else if (type === "object") {
    if ((obj == null ? void 0 : obj.isNode) === true) {
      let nodeObject2 = nodeObjectsCacheMap.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, shaderNodeHandler);
        nodeObjectsCacheMap.set(obj, nodeObject2);
        nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
var ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name]);
  }
  return objects;
};
var ShaderNodeArray = function(array) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i]);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null) {
  if (scope === null) {
    return (...params) => {
      return nodeObject(new NodeClass(...nodeArray(params)));
    };
  } else if (factor === null) {
    return (...params) => {
      return nodeObject(new NodeClass(scope, ...nodeArray(params)));
    };
  } else {
    factor = nodeObject(factor);
    return (...params) => {
      return nodeObject(new NodeClass(scope, ...nodeArray(params), factor));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderNodeScript = function(jsFunc) {
  const self = {
    build: (builder) => {
      self.call({}, builder);
      return "";
    },
    call: (inputs, builder) => {
      inputs = nodeObjects(inputs);
      return nodeObject(jsFunc(inputs, builder));
    }
  };
  return self;
};
var ShaderNode = new Proxy(ShaderNodeScript, shaderNodeHandler);
var nodeObject = (val) => (
  /* new */
  ShaderNodeObject(val)
);
var nodeObjects = (val) => new ShaderNodeObjects(val);
var nodeArray = (val) => new ShaderNodeArray(val);
var nodeProxy = (...val) => new ShaderNodeProxy(...val);
var nodeImmutable = (...val) => new ShaderNodeImmutable(...val);
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (let bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (let uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (let int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (let float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (let float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value);
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode_default(getValueFromType(type), type));
    } else {
      if (type === "color" && params[0].isNode !== true) {
        params = [getValueFromType(type, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      if (nodes.length === 1) {
        return nodeObject(nodes[0].nodeType === type ? nodes[0] : new ConvertNode_default(nodes[0], type));
      }
      return nodeObject(new ConvertNode_default(new JoinNode_default(nodes), type));
    }
  };
};
var getConstNodeType = (value) => value.nodeType || value.convertTo || (typeof value === "string" ? value : null);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeBaseElements.js
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.int);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var func = (code2) => {
  const node = nodeObject(new FunctionNode_default(code2));
  const call2 = node.call.bind(node);
  node.call = (params) => nodeObject(call2(params));
  return node;
};
var uniform = (nodeOrType) => {
  var _a;
  const nodeType = getConstNodeType(nodeOrType);
  const value = nodeOrType.isNode === true ? ((_a = nodeOrType.node) == null ? void 0 : _a.value) || nodeOrType.value : nodeOrType;
  return nodeObject(new UniformNode_default(value, nodeType));
};
var attribute = (name, nodeOrType) => nodeObject(new AttributeNode_default(name, getConstNodeType(nodeOrType)));
var property = (name, nodeOrType) => nodeObject(new PropertyNode_default(name, getConstNodeType(nodeOrType)));
var bypass = nodeProxy(BypassNode_default);
var code = nodeProxy(CodeNode_default);
var context = nodeProxy(ContextNode_default);
var expression = nodeProxy(ExpressionNode_default);
var call = nodeProxy(FunctionCallNode_default);
var instanceIndex = nodeImmutable(InstanceIndexNode_default);
var label = nodeProxy(VarNode_default);
var temp = label;
var vary = nodeProxy(VaryNode_default);
var buffer = (value, nodeOrType, count) => nodeObject(new BufferNode_default(value, getConstNodeType(nodeOrType), count));
var storage = (value, nodeOrType, count) => nodeObject(new StorageBufferNode_default(value, getConstNodeType(nodeOrType), count));
var cameraProjectionMatrix = nodeImmutable(CameraNode_default, CameraNode_default.PROJECTION_MATRIX);
var cameraViewMatrix = nodeImmutable(CameraNode_default, CameraNode_default.VIEW_MATRIX);
var cameraNormalMatrix = nodeImmutable(CameraNode_default, CameraNode_default.NORMAL_MATRIX);
var cameraWorldMatrix = nodeImmutable(CameraNode_default, CameraNode_default.WORLD_MATRIX);
var cameraPosition = nodeImmutable(CameraNode_default, CameraNode_default.POSITION);
var materialAlphaTest = nodeImmutable(MaterialNode_default, MaterialNode_default.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode_default, MaterialNode_default.COLOR);
var materialOpacity = nodeImmutable(MaterialNode_default, MaterialNode_default.OPACITY);
var materialSpecular = nodeImmutable(MaterialNode_default, MaterialNode_default.SPECULAR);
var materialRoughness = nodeImmutable(MaterialNode_default, MaterialNode_default.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode_default, MaterialNode_default.METALNESS);
var diffuseColor = nodeImmutable(PropertyNode_default, "DiffuseColor", "vec4");
var roughness = nodeImmutable(PropertyNode_default, "Roughness", "float");
var metalness = nodeImmutable(PropertyNode_default, "Metalness", "float");
var alphaTest = nodeImmutable(PropertyNode_default, "AlphaTest", "float");
var specularColor = nodeImmutable(PropertyNode_default, "SpecularColor", "color");
var reference = (name, nodeOrType, object) => nodeObject(new ReferenceNode_default(name, getConstNodeType(nodeOrType), object));
var materialReference = (name, nodeOrType, material) => nodeObject(new MaterialReferenceNode_default(name, getConstNodeType(nodeOrType), material));
var modelViewProjection = nodeProxy(ModelViewProjectionNode_default);
var normalGeometry = nodeImmutable(NormalNode_default, NormalNode_default.GEOMETRY);
var normalLocal = nodeImmutable(NormalNode_default, NormalNode_default.LOCAL);
var normalWorld = nodeImmutable(NormalNode_default, NormalNode_default.WORLD);
var normalView = nodeImmutable(NormalNode_default, NormalNode_default.VIEW);
var transformedNormalView = nodeImmutable(VarNode_default, normalView, "TransformedNormalView");
var viewMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.VIEW_MATRIX);
var normalMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.NORMAL_MATRIX);
var worldMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.WORLD_MATRIX);
var position = nodeProxy(Object3DNode_default, Object3DNode_default.POSITION);
var viewPosition = nodeProxy(Object3DNode_default, Object3DNode_default.VIEW_POSITION);
var positionGeometry = nodeImmutable(PositionNode_default, PositionNode_default.GEOMETRY);
var positionLocal = nodeImmutable(PositionNode_default, PositionNode_default.LOCAL);
var positionWorld = nodeImmutable(PositionNode_default, PositionNode_default.WORLD);
var positionView = nodeImmutable(PositionNode_default, PositionNode_default.VIEW);
var positionViewDirection = nodeImmutable(PositionNode_default, PositionNode_default.VIEW_DIRECTION);
var texture = nodeProxy(TextureNode_default);
var sampler = (texture2) => nodeObject(new ConvertNode_default(texture2.isNode === true ? texture2 : new TextureNode_default(texture2), "sampler"));
var uv = (...params) => nodeObject(new UVNode_default(...params));
var pointUV = nodeImmutable(PointUVNode_default);
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode_default(nodeObject(node), count, workgroupSize));
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var cond = nodeProxy(CondNode_default);
var add = nodeProxy(OperatorNode_default, "+");
var sub = nodeProxy(OperatorNode_default, "-");
var mul = nodeProxy(OperatorNode_default, "*");
var div = nodeProxy(OperatorNode_default, "/");
var remainder = nodeProxy(OperatorNode_default, "%");
var equal = nodeProxy(OperatorNode_default, "==");
var assign = nodeProxy(OperatorNode_default, "=");
var lessThan = nodeProxy(OperatorNode_default, "<");
var greaterThan = nodeProxy(OperatorNode_default, ">");
var lessThanEqual = nodeProxy(OperatorNode_default, "<=");
var greaterThanEqual = nodeProxy(OperatorNode_default, ">=");
var and = nodeProxy(OperatorNode_default, "&&");
var or = nodeProxy(OperatorNode_default, "||");
var xor = nodeProxy(OperatorNode_default, "^^");
var bitAnd = nodeProxy(OperatorNode_default, "&");
var bitOr = nodeProxy(OperatorNode_default, "|");
var bitXor = nodeProxy(OperatorNode_default, "^");
var shiftLeft = nodeProxy(OperatorNode_default, "<<");
var shiftRight = nodeProxy(OperatorNode_default, ">>");
var radians = nodeProxy(MathNode_default, MathNode_default.RADIANS);
var degrees = nodeProxy(MathNode_default, MathNode_default.DEGREES);
var exp = nodeProxy(MathNode_default, MathNode_default.EXP);
var exp2 = nodeProxy(MathNode_default, MathNode_default.EXP2);
var log = nodeProxy(MathNode_default, MathNode_default.LOG);
var log2 = nodeProxy(MathNode_default, MathNode_default.LOG2);
var sqrt = nodeProxy(MathNode_default, MathNode_default.SQRT);
var inversesqrt = nodeProxy(MathNode_default, MathNode_default.INVERSE_SQRT);
var floor = nodeProxy(MathNode_default, MathNode_default.FLOOR);
var ceil = nodeProxy(MathNode_default, MathNode_default.CEIL);
var normalize = nodeProxy(MathNode_default, MathNode_default.NORMALIZE);
var fract = nodeProxy(MathNode_default, MathNode_default.FRACT);
var sin = nodeProxy(MathNode_default, MathNode_default.SIN);
var cos = nodeProxy(MathNode_default, MathNode_default.COS);
var tan = nodeProxy(MathNode_default, MathNode_default.TAN);
var asin = nodeProxy(MathNode_default, MathNode_default.ASIN);
var acos = nodeProxy(MathNode_default, MathNode_default.ACOS);
var atan = nodeProxy(MathNode_default, MathNode_default.ATAN);
var abs = nodeProxy(MathNode_default, MathNode_default.ABS);
var sign = nodeProxy(MathNode_default, MathNode_default.SIGN);
var length = nodeProxy(MathNode_default, MathNode_default.LENGTH);
var negate = nodeProxy(MathNode_default, MathNode_default.NEGATE);
var invert = nodeProxy(MathNode_default, MathNode_default.INVERT);
var dFdx = nodeProxy(MathNode_default, MathNode_default.DFDX);
var dFdy = nodeProxy(MathNode_default, MathNode_default.DFDY);
var saturate = nodeProxy(MathNode_default, MathNode_default.SATURATE);
var round = nodeProxy(MathNode_default, MathNode_default.ROUND);
var min = nodeProxy(MathNode_default, MathNode_default.MIN);
var max = nodeProxy(MathNode_default, MathNode_default.MAX);
var mod = nodeProxy(MathNode_default, MathNode_default.MOD);
var step = nodeProxy(MathNode_default, MathNode_default.STEP);
var reflect = nodeProxy(MathNode_default, MathNode_default.REFLECT);
var distance = nodeProxy(MathNode_default, MathNode_default.DISTANCE);
var dot = nodeProxy(MathNode_default, MathNode_default.DOT);
var cross = nodeProxy(MathNode_default, MathNode_default.CROSS);
var pow = nodeProxy(MathNode_default, MathNode_default.POW);
var pow2 = nodeProxy(MathNode_default, MathNode_default.POW, 2);
var pow3 = nodeProxy(MathNode_default, MathNode_default.POW, 3);
var pow4 = nodeProxy(MathNode_default, MathNode_default.POW, 4);
var transformDirection = nodeProxy(MathNode_default, MathNode_default.TRANSFORM_DIRECTION);
var mix = nodeProxy(MathNode_default, MathNode_default.MIX);
var clamp = nodeProxy(MathNode_default, MathNode_default.CLAMP);
var refract = nodeProxy(MathNode_default, MathNode_default.REFRACT);
var smoothstep = nodeProxy(MathNode_default, MathNode_default.SMOOTHSTEP);
var faceforward = nodeProxy(MathNode_default, MathNode_default.FACEFORWARD);
var frontFacing = nodeImmutable(FrontFacingNode_default);
var faceDirection = sub(mul(float(frontFacing), 2), 1);
var reflectedLight = nodeProxy(ReflectedLightNode_default);
var element = nodeProxy(ArrayElementNode_default);
var dotNV = saturate(dot(transformedNormalView, positionViewDirection));

export {
  NodeUpdateType,
  Node_default,
  ContextNode_default,
  TempNode_default,
  UniformNode_default,
  OperatorNode_default,
  Object3DNode_default,
  ModelNode_default,
  JoinNode_default,
  SplitNode_default,
  MathNode_default,
  PositionNode_default,
  UVNode_default,
  TextureNode_default,
  ConstNode_default,
  ShaderNode,
  nodeObject,
  nodeObjects,
  nodeArray,
  nodeProxy,
  nodeImmutable,
  color,
  float,
  int,
  uint,
  bool,
  vec2,
  ivec2,
  uvec2,
  bvec2,
  vec3,
  ivec3,
  uvec3,
  bvec3,
  vec4,
  ivec4,
  uvec4,
  bvec4,
  mat3,
  imat3,
  umat3,
  bmat3,
  mat4,
  imat4,
  umat4,
  bmat4,
  func,
  uniform,
  attribute,
  property,
  bypass,
  code,
  context,
  expression,
  call,
  instanceIndex,
  label,
  temp,
  vary,
  buffer,
  storage,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraNormalMatrix,
  cameraWorldMatrix,
  cameraPosition,
  materialAlphaTest,
  materialColor,
  materialOpacity,
  materialSpecular,
  materialRoughness,
  materialMetalness,
  diffuseColor,
  roughness,
  metalness,
  alphaTest,
  specularColor,
  reference,
  materialReference,
  modelViewProjection,
  normalGeometry,
  normalLocal,
  normalWorld,
  normalView,
  transformedNormalView,
  viewMatrix,
  normalMatrix,
  worldMatrix,
  position,
  viewPosition,
  positionGeometry,
  positionLocal,
  positionWorld,
  positionView,
  positionViewDirection,
  texture,
  sampler,
  uv,
  pointUV,
  compute,
  EPSILON,
  INFINITY,
  cond,
  add,
  sub,
  mul,
  div,
  remainder,
  equal,
  assign,
  lessThan,
  greaterThan,
  lessThanEqual,
  greaterThanEqual,
  and,
  or,
  xor,
  bitAnd,
  bitOr,
  bitXor,
  shiftLeft,
  shiftRight,
  radians,
  degrees,
  exp,
  exp2,
  log,
  log2,
  sqrt,
  inversesqrt,
  floor,
  ceil,
  normalize,
  fract,
  sin,
  cos,
  tan,
  asin,
  acos,
  atan,
  abs,
  sign,
  length,
  negate,
  invert,
  dFdx,
  dFdy,
  saturate,
  round,
  min,
  max,
  mod,
  step,
  reflect,
  distance,
  dot,
  cross,
  pow,
  pow2,
  pow3,
  pow4,
  transformDirection,
  mix,
  clamp,
  refract,
  smoothstep,
  faceforward,
  frontFacing,
  faceDirection,
  reflectedLight,
  element,
  dotNV
};
//# sourceMappingURL=chunk-DIFZRYKC.js.map
