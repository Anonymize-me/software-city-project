import {
  ConstNode_default,
  ContextNode_default,
  EPSILON,
  INFINITY,
  JoinNode_default,
  MathNode_default,
  ModelNode_default,
  NodeUpdateType,
  Node_default,
  Object3DNode_default,
  OperatorNode_default,
  PositionNode_default,
  ShaderNode,
  SplitNode_default,
  TempNode_default,
  TextureNode_default,
  UVNode_default,
  UniformNode_default,
  abs,
  acos,
  add,
  alphaTest,
  and,
  asin,
  assign,
  atan,
  attribute,
  bitAnd,
  bitOr,
  bitXor,
  bmat3,
  bmat4,
  bool,
  buffer,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  call,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  clamp,
  code,
  color,
  compute,
  cond,
  context,
  cos,
  cross,
  dFdx,
  dFdy,
  degrees,
  diffuseColor,
  distance,
  div,
  dot,
  dotNV,
  element,
  equal,
  exp,
  exp2,
  expression,
  faceDirection,
  faceforward,
  float,
  floor,
  fract,
  frontFacing,
  func,
  greaterThan,
  greaterThanEqual,
  imat3,
  imat4,
  instanceIndex,
  int,
  inversesqrt,
  invert,
  ivec2,
  ivec3,
  ivec4,
  label,
  length,
  lessThan,
  lessThanEqual,
  log,
  log2,
  mat3,
  mat4,
  materialAlphaTest,
  materialColor,
  materialMetalness,
  materialOpacity,
  materialReference,
  materialRoughness,
  materialSpecular,
  max,
  metalness,
  min,
  mix,
  mod,
  modelViewProjection,
  mul,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMatrix,
  normalView,
  normalWorld,
  normalize,
  or,
  pointUV,
  position,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  reference,
  reflect,
  reflectedLight,
  refract,
  remainder,
  roughness,
  round,
  sampler,
  saturate,
  shiftLeft,
  shiftRight,
  sign,
  sin,
  smoothstep,
  specularColor,
  sqrt,
  step,
  storage,
  sub,
  tan,
  temp,
  texture,
  transformDirection,
  transformedNormalView,
  uint,
  umat3,
  umat4,
  uniform,
  uv,
  uvec2,
  uvec3,
  uvec4,
  vary,
  vec2,
  vec3,
  vec4,
  viewMatrix,
  viewPosition,
  worldMatrix,
  xor
} from "./chunk-DIFZRYKC.js";
import "./chunk-4KORGJVV.js";
import {
  Color,
  LinearEncoding,
  LinearToneMapping,
  ObjectSpaceNormalMap,
  TangentSpaceNormalMap,
  sRGBEncoding
} from "./chunk-MCRSFNJN.js";
import {
  __publicField
} from "./chunk-XNHBATJA.js";

// node_modules/three/examples/jsm/nodes/accessors/ReflectNode.js
var _ReflectNode = class _ReflectNode extends Node_default {
  constructor(scope = _ReflectNode.CUBE) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `reflect-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _ReflectNode.VECTOR) {
      const cameraToFrag = normalize(sub(positionWorld, cameraPosition));
      const reflectVec = reflect(cameraToFrag, normalWorld);
      return reflectVec.build(builder);
    } else if (scope === _ReflectNode.CUBE) {
      const reflectVec = nodeObject(new _ReflectNode(_ReflectNode.VECTOR));
      const cubeUV = vec3(negate(reflectVec.x), reflectVec.yz);
      return cubeUV.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_ReflectNode, "VECTOR", "vector");
__publicField(_ReflectNode, "CUBE", "cube");
var ReflectNode = _ReflectNode;
var ReflectNode_default = ReflectNode;

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = new ReflectNode_default(), biasNode = null) {
    super(value, uvNode, biasNode);
  }
  getInputType() {
    return "cubeTexture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec3");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getCubeTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getCubeTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
};
CubeTextureNode.prototype.isCubeTextureNode = true;
var CubeTextureNode_default = CubeTextureNode;

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    const instanceBufferNode = buffer(instanceMesh.instanceMatrix.array, "mat4", instanceMesh.count);
    this.instanceMatrixNode = temp(element(instanceBufferNode, instanceIndex));
  }
  generate(builder) {
    const { instanceMatrixNode } = this;
    const instancePosition = mul(instanceMatrixNode, positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = div(normalLocal, vec3(dot(m[0], m[0]), dot(m[1], m[1]), dot(m[2], m[2])));
    const instanceNormal = mul(m, transformedNormal).xyz;
    assign(positionLocal, instancePosition).build(builder);
    assign(normalLocal, instanceNormal).build(builder);
  }
};
var InstanceNode_default = InstanceNode;

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var Skinning = new ShaderNode((inputs, builder) => {
  const { index, weight, bindMatrix, bindMatrixInverse, boneMatrices } = inputs;
  const boneMatX = element(boneMatrices, index.x);
  const boneMatY = element(boneMatrices, index.y);
  const boneMatZ = element(boneMatrices, index.z);
  const boneMatW = element(boneMatrices, index.w);
  const skinVertex = mul(bindMatrix, positionLocal);
  const skinned = add(
    mul(mul(boneMatX, skinVertex), weight.x),
    mul(mul(boneMatY, skinVertex), weight.y),
    mul(mul(boneMatZ, skinVertex), weight.z),
    mul(mul(boneMatW, skinVertex), weight.w)
  );
  const skinPosition = mul(bindMatrixInverse, skinned).xyz;
  let skinMatrix = add(
    mul(weight.x, boneMatX),
    mul(weight.y, boneMatY),
    mul(weight.z, boneMatZ),
    mul(weight.w, boneMatW)
  );
  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);
  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz;
  assign(positionLocal, skinPosition).build(builder);
  assign(normalLocal, skinNormal).build(builder);
});
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.Object;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = uniform(mat4(skinnedMesh.bindMatrix));
    this.bindMatrixInverseNode = uniform(mat4(skinnedMesh.bindMatrixInverse));
    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  }
  generate(builder) {
    Skinning.call({
      index: this.skinIndexNode,
      weight: this.skinWeightNode,
      bindMatrix: this.bindMatrixNode,
      bindMatrixInverse: this.bindMatrixInverseNode,
      boneMatrices: this.boneMatricesNode
    }, builder);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var LinearToLinear = new ShaderNode((inputs) => {
  return inputs.value;
});
var LinearTosRGB = new ShaderNode((inputs) => {
  const { value } = inputs;
  const rgb = value.rgb;
  const a = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));
  const b = mul(rgb, 12.92);
  const factor = vec3(lessThanEqual(rgb, vec3(31308e-7)));
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
var _ColorSpaceNode = class _ColorSpaceNode extends Node_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromEncoding(encoding) {
    let method = null;
    if (encoding === LinearEncoding) {
      method = "Linear";
    } else if (encoding === sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const method = this.method;
    const node = this.node;
    if (method !== _ColorSpaceNode.LINEAR_TO_LINEAR) {
      const encodingFunctionNode = EncodingLib[method];
      return encodingFunctionNode.call({
        value: node
      }).build(builder, type);
    } else {
      return node.build(builder, type);
    }
  }
};
__publicField(_ColorSpaceNode, "LINEAR_TO_LINEAR", "LinearToLinear");
__publicField(_ColorSpaceNode, "LINEAR_TO_SRGB", "LinearTosRGB");
var ColorSpaceNode = _ColorSpaceNode;
var ColorSpaceNode_default = ColorSpaceNode;

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2ArbNode = new ShaderNode((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = dFdx(eye_pos.xyz);
  const q1 = dFdy(eye_pos.xyz);
  const st0 = dFdx(uv2.st);
  const st1 = dFdy(uv2.st);
  const N = surf_norm;
  const q1perp = cross(q1, N);
  const q0perp = cross(N, q0);
  const T = add(mul(q1perp, st0.x), mul(q0perp, st1.x));
  const B = add(mul(q1perp, st0.y), mul(q0perp, st1.y));
  const det = max(dot(T, T), dot(B, B));
  const scale = cond(equal(det, 0), 0, mul(faceDirection, inversesqrt(det)));
  return normalize(add(mul(T, mul(mapN.x, scale)), mul(B, mul(mapN.y, scale)), mul(N, mapN.z)));
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const { normalMapType, scaleNode } = this;
    const normalOP = mul(this.node, 2);
    let normalMap2 = sub(normalOP, 1);
    if (scaleNode !== null) {
      const normalMapScale = mul(normalMap2.xy, scaleNode);
      normalMap2 = vec3(normalMapScale, normalMap2.z);
    }
    if (normalMapType === ObjectSpaceNormalMap) {
      const vertexNormalNode = mul(new ModelNode_default(ModelNode_default.NORMAL_MATRIX), normalMap2);
      const normal = normalize(vertexNormalNode);
      return normal.build(builder, type);
    } else if (normalMapType === TangentSpaceNormalMap) {
      const perturbNormal2ArbCall = perturbNormal2ArbNode.call({
        eye_pos: positionView,
        surf_norm: normalView,
        mapN: normalMap2,
        uv: uv()
      });
      return perturbNormal2ArbCall.build(builder, type);
    }
  }
};
var NormalMapNode_default = NormalMapNode;

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  return mul(color2, exposure);
});
var ToneMappingNode = class extends Node_default {
  constructor(toneMapping2, exposureNode = float(1), colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const colorNode = this.color || builder.context.color;
    const toneMapping2 = this.toneMapping;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    if (toneMapping2 === LinearToneMapping) {
      return LinearToneMappingNode.call(toneMappingParams).build(builder, type);
    } else {
      return this.colorNode.build(builder, type);
    }
  }
};
var ToneMappingNode_default = ToneMappingNode;

// node_modules/three/examples/jsm/nodes/functions/light/getDistanceAttenuation.js
var getDistanceAttenuation = new ShaderNode((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = div(1, max(pow(lightDistance, decayExponent), 0.01));
  return cond(
    greaterThan(cutoffDistance, 0),
    mul(distanceFalloff, pow2(saturate(sub(1, pow4(div(lightDistance, cutoffDistance)))))),
    distanceFalloff
  );
});
var getDistanceAttenuation_default = getDistanceAttenuation;

// node_modules/three/examples/jsm/nodes/lights/LightNode.js
var LightNode = class extends Node_default {
  constructor(light2 = null) {
    super("vec3");
    this.updateType = NodeUpdateType.Object;
    this.light = light2;
    this._colorNode = new UniformNode_default(new Color());
    this._lightCutoffDistanceNode = new UniformNode_default(0);
    this._lightDecayExponentNode = new UniformNode_default(0);
  }
  getHash() {
    return this.light.uuid;
  }
  update() {
    this._colorNode.value.copy(this.light.color).multiplyScalar(this.light.intensity);
    this._lightCutoffDistanceNode.value = this.light.distance;
    this._lightDecayExponentNode.value = this.light.decay;
  }
  generate(builder) {
    const lightPositionView = new Object3DNode_default(Object3DNode_default.VIEW_POSITION);
    const positionView2 = new PositionNode_default(PositionNode_default.VIEW);
    const lVector = new OperatorNode_default("-", lightPositionView, positionView2);
    const lightDirection = new MathNode_default(MathNode_default.NORMALIZE, lVector);
    const lightDistance = new MathNode_default(MathNode_default.LENGTH, lVector);
    const lightAttenuation = getDistanceAttenuation_default.call({
      lightDistance,
      cutoffDistance: this._lightCutoffDistanceNode,
      decayExponent: this._lightDecayExponentNode
    });
    const lightColor = new OperatorNode_default("*", this._colorNode, lightAttenuation);
    lightPositionView.object3d = this.light;
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    if (lightingModelFunctionNode !== void 0) {
      const reflectedLight2 = builder.context.reflectedLight;
      lightingModelFunctionNode.call({
        lightDirection,
        lightColor,
        reflectedLight: reflectedLight2
      }, builder);
    }
  }
};
var LightNode_default = LightNode;

// node_modules/three/examples/jsm/nodes/lights/LightsNode.js
var sortLights = (lights) => {
  return lights.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  generate(builder) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
    return "vec3( 0.0 )";
  }
  getHash() {
    if (this._hash === null) {
      let hash = "";
      const lightNodes = this.lightNodes;
      for (const lightNode of lightNodes) {
        hash += lightNode.light.uuid + " ";
      }
      this._hash = hash;
    }
    return this._hash;
  }
  getLightNodeByHash(hash) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      if (lightNode.light.uuid === hash) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights) {
    const lightNodes = [];
    lights = sortLights(lights);
    for (const light2 of lights) {
      let lightNode = this.getLightNodeByHash(light2.uuid);
      if (lightNode === null) {
        lightNode = new LightNode_default(light2);
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
};
var LightsNode_default = LightsNode;

// node_modules/three/examples/jsm/nodes/lights/LightContextNode.js
var LightContextNode = class extends ContextNode_default {
  constructor(node, lightingModelNode = null) {
    super(node);
    this.lightingModelNode = lightingModelNode;
  }
  getNodeType() {
    return "vec3";
  }
  generate(builder) {
    const { lightingModelNode } = this;
    this.context.reflectedLight = reflectedLight();
    if (lightingModelNode !== null) {
      this.context.lightingModelNode = lightingModelNode;
    }
    const type = this.getNodeType(builder);
    super.generate(builder, type);
    return this.context.reflectedLight.build(builder, type);
  }
};
var LightContextNode_default = LightContextNode;

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  generate(builder) {
    const x = normalize(vec3(positionViewDirection.z, 0, negate(positionViewDirection.x)));
    const y = cross(positionViewDirection, x);
    const uv2 = add(mul(vec2(dot(x, transformedNormalView), dot(y, transformedNormalView)), 0.495), 0.5);
    return uv2.build(builder, this.getNodeType(builder));
  }
};
var MatcapUVNode_default = MatcapUVNode;

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(texture2) {
    super(0);
    this.texture = texture2;
    this.updateType = NodeUpdateType.Frame;
  }
  update() {
    const { width, height } = this.texture.images ? this.texture.images[0] : this.texture.image;
    this.value = Math.log(Math.max(width, height)) * Math.LOG2E;
    if (this.value > 0) {
      this.updateType = NodeUpdateType.None;
    }
  }
};
var MaxMipLevelNode_default = MaxMipLevelNode;

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var _TimerNode = class _TimerNode extends UniformNode_default {
  constructor(scope = _TimerNode.LOCAL) {
    super(0);
    this.scope = scope;
    this.scale = 1;
    this.updateType = NodeUpdateType.Frame;
  }
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === _TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === _TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
__publicField(_TimerNode, "LOCAL", "local");
__publicField(_TimerNode, "GLOBAL", "global");
__publicField(_TimerNode, "DELTA", "delta");
var TimerNode = _TimerNode;
var TimerNode_default = TimerNode;

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var _OscNode = class _OscNode extends Node_default {
  constructor(method = _OscNode.SINE, timeNode = new TimerNode_default()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  generate(builder) {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = round(fract(timeNode));
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = fract(timeNode);
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
__publicField(_OscNode, "SINE", "sine");
__publicField(_OscNode, "SQUARE", "square");
__publicField(_OscNode, "TRIANGLE", "triangle");
__publicField(_OscNode, "SAWTOOTH", "sawtooth");
var OscNode = _OscNode;
var OscNode_default = OscNode;

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = new UVNode_default(), frameNode = new ConstNode_default(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  generate(builder) {
    const count = this.countNode;
    const uv2 = this.uvNode;
    const frame = this.frameNode;
    const one = new ConstNode_default(1);
    const width = new SplitNode_default(count, "x");
    const height = new SplitNode_default(count, "y");
    const total = new OperatorNode_default("*", width, height);
    const roundFrame = new MathNode_default(MathNode_default.FLOOR, new MathNode_default(MathNode_default.MOD, frame, total));
    const frameNum = new OperatorNode_default("+", roundFrame, one);
    const cell = new MathNode_default(MathNode_default.MOD, roundFrame, width);
    const row = new MathNode_default(MathNode_default.CEIL, new OperatorNode_default("/", frameNum, width));
    const rowInv = new OperatorNode_default("-", height, row);
    const scale = new OperatorNode_default("/", one, count);
    const uvFrameOffset = new JoinNode_default([
      new OperatorNode_default("*", cell, new SplitNode_default(scale, "x")),
      new OperatorNode_default("*", rowInv, new SplitNode_default(scale, "y"))
    ]);
    const uvScale = new OperatorNode_default("*", uv2, scale);
    const uvFrame = new OperatorNode_default("+", uvScale, uvFrameOffset);
    return uvFrame.build(builder, this.getNodeType(builder));
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = new ShaderNode((inputs) => {
  const uv2 = mul(inputs.uv, 2);
  const cx = floor(uv2.x);
  const cy = floor(uv2.y);
  const result = mod(add(cx, cy), 2);
  return sign(result);
});
var CheckerNode = class extends Node_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  generate(builder) {
    return checkerShaderNode.call({ uv: this.uvNode }).build(builder);
  }
};
var CheckerNode_default = CheckerNode;

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  mix(outputNode) {
    return new MathNode_default(MathNode_default.MIX, outputNode, this.colorNode, this);
  }
  generate(builder) {
    return this.factorNode.build(builder, "float");
  }
};
FogNode.prototype.isFogNode = true;
var FogNode_default = FogNode;

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  generate(builder) {
    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));
    return super.generate(builder);
  }
};
FogRangeNode.prototype.isFogRangeNode = true;
var FogRangeNode_default = FogRangeNode;

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = new ShaderNode((inputs) => {
  const { f0, f90, dotVH } = inputs;
  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));
  return add(mul(f0, sub(1, fresnel)), mul(f90, fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const { alpha, dotNL, dotNV: dotNV2 } = inputs;
  const a2 = pow2(alpha);
  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1, a2), pow2(dotNV2)))));
  const gl = mul(dotNV2, sqrt(add(a2, mul(sub(1, a2), pow2(dotNL)))));
  return div(0.5, max(add(gv, gl), EPSILON));
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = new ShaderNode((inputs) => {
  const { alpha, dotNH } = inputs;
  const a2 = pow2(alpha);
  const denom = add(mul(pow2(dotNH), sub(a2, 1)), 1);
  return mul(1 / Math.PI, div(a2, pow2(denom)));
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = new ShaderNode((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2 } = inputs;
  const alpha = pow2(roughness2);
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const dotNH = saturate(dot(transformedNormalView, halfDir));
  const dotVH = saturate(dot(positionViewDirection, halfDir));
  const F = F_Schlick_default.call({ f0, f90, dotVH });
  const V = V_GGX_SmithCorrelated_default.call({ alpha, dotNL, dotNV });
  const D = D_GGX_default.call({ alpha, dotNH });
  return mul(F, mul(V, D));
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = new ShaderNode((inputs) => {
  return mul(1 / Math.PI, inputs.diffuseColor);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = new ShaderNode(() => {
  const dxy = max(abs(dFdx(normalGeometry)), abs(dFdy(normalGeometry)));
  const geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = new ShaderNode((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default.call();
  let roughnessFactor = max(roughness2, 0.0525);
  roughnessFactor = add(roughnessFactor, geometryRoughness);
  roughnessFactor = min(roughnessFactor, 1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var RE_Direct_Physical = new ShaderNode((inputs) => {
  const { lightDirection, lightColor, reflectedLight: reflectedLight2 } = inputs;
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const irradiance = mul(dotNL, lightColor);
  reflectedLight2.directSpecular.add(mul(irradiance, BRDF_GGX_default.call({ lightDirection, f0: specularColor, f90: 1, roughness })));
  reflectedLight2.directDiffuse.add(mul(irradiance, BRDF_Lambert_default.call({ diffuseColor: diffuseColor.rgb })));
});
var PhysicalLightingModel = new ShaderNode((inputs) => {
  RE_Direct_Physical.call(inputs);
});
var PhysicalLightingModel_default = PhysicalLightingModel;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeElements.js
var cubeTexture = nodeProxy(CubeTextureNode_default);
var instance = nodeProxy(InstanceNode_default);
var reflectVector = nodeImmutable(ReflectNode_default, ReflectNode_default.VECTOR);
var reflectCube = nodeImmutable(ReflectNode_default, ReflectNode_default.CUBE);
var skinning = nodeProxy(SkinningNode_default);
var colorSpace = (node, encoding) => nodeObject(new ColorSpaceNode_default(null, nodeObject(node)).fromEncoding(encoding));
var normalMap = nodeProxy(NormalMapNode_default);
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode_default(mapping, nodeObject(exposure), nodeObject(color2)));
var light = nodeProxy(LightNode_default);
var fromLights = (lights) => nodeObject(new LightsNode_default().fromLights(lights));
var lightContext = nodeProxy(LightContextNode_default);
var matcapUV = nodeImmutable(MatcapUVNode_default);
var maxMipLevel = nodeProxy(MaxMipLevelNode_default);
var oscSine = nodeProxy(OscNode_default, OscNode_default.SINE);
var oscSquare = nodeProxy(OscNode_default, OscNode_default.SQUARE);
var oscTriangle = nodeProxy(OscNode_default, OscNode_default.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode_default, OscNode_default.SAWTOOTH);
var spritesheetUV = nodeProxy(SpriteSheetUVNode_default);
var timerLocal = nodeImmutable(TimerNode_default, TimerNode_default.LOCAL);
var timerGlobal = nodeImmutable(TimerNode_default, TimerNode_default.GLOBAL);
var timerDelta = nodeImmutable(TimerNode_default, TimerNode_default.DELTA);
var checker = nodeProxy(CheckerNode_default);
var fog = nodeProxy(FogNode_default);
var rangeFog = nodeProxy(FogRangeNode_default);
export {
  BRDF_GGX_default as BRDF_GGX,
  BRDF_Lambert_default as BRDF_Lambert,
  D_GGX_default as D_GGX,
  EPSILON,
  F_Schlick_default as F_Schlick,
  INFINITY,
  PhysicalLightingModel_default as PhysicalLightingModel,
  ShaderNode,
  V_GGX_SmithCorrelated_default as V_GGX_SmithCorrelated,
  abs,
  acos,
  add,
  alphaTest,
  and,
  asin,
  assign,
  atan,
  attribute,
  bitAnd,
  bitOr,
  bitXor,
  bmat3,
  bmat4,
  bool,
  buffer,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  call,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  checker,
  clamp,
  code,
  color,
  colorSpace,
  compute,
  cond,
  context,
  cos,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  degrees,
  diffuseColor,
  distance,
  div,
  dot,
  dotNV,
  element,
  equal,
  exp,
  exp2,
  expression,
  faceDirection,
  faceforward,
  float,
  floor,
  fog,
  fract,
  fromLights,
  frontFacing,
  func,
  getDistanceAttenuation_default as getDistanceAttenuation,
  getGeometryRoughness_default as getGeometryRoughness,
  getRoughness_default as getRoughness,
  greaterThan,
  greaterThanEqual,
  imat3,
  imat4,
  instance,
  instanceIndex,
  int,
  inversesqrt,
  invert,
  ivec2,
  ivec3,
  ivec4,
  label,
  length,
  lessThan,
  lessThanEqual,
  light,
  lightContext,
  log,
  log2,
  mat3,
  mat4,
  matcapUV,
  materialAlphaTest,
  materialColor,
  materialMetalness,
  materialOpacity,
  materialReference,
  materialRoughness,
  materialSpecular,
  max,
  maxMipLevel,
  metalness,
  min,
  mix,
  mod,
  modelViewProjection,
  mul,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMap,
  normalMatrix,
  normalView,
  normalWorld,
  normalize,
  or,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  pointUV,
  position,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  rangeFog,
  reference,
  reflect,
  reflectCube,
  reflectVector,
  reflectedLight,
  refract,
  remainder,
  roughness,
  round,
  sampler,
  saturate,
  shiftLeft,
  shiftRight,
  sign,
  sin,
  skinning,
  smoothstep,
  specularColor,
  spritesheetUV,
  sqrt,
  step,
  storage,
  sub,
  tan,
  temp,
  texture,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  transformDirection,
  transformedNormalView,
  uint,
  umat3,
  umat4,
  uniform,
  uv,
  uvec2,
  uvec3,
  uvec4,
  vary,
  vec2,
  vec3,
  vec4,
  viewMatrix,
  viewPosition,
  worldMatrix,
  xor
};
//# sourceMappingURL=three_examples_jsm_nodes_shadernode_ShaderNodeElements.js.map
