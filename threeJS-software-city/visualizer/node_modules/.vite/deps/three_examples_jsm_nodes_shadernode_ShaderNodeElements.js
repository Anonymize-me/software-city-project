import {
  getNodesKeys,
  getValueFromType,
  getValueType
} from "./chunk-4KORGJVV.js";
import {
  Color,
  LinearEncoding,
  LinearToneMapping,
  MathUtils,
  ObjectSpaceNormalMap,
  TangentSpaceNormalMap,
  Vector3,
  sRGBEncoding
} from "./chunk-MCRSFNJN.js";
import {
  __publicField
} from "./chunk-2B2CG5KL.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  Vertex: "vertex",
  Fragment: "fragment"
};
var NodeUpdateType = {
  None: "none",
  Frame: "frame",
  Object: "object"
};

// node_modules/three/examples/jsm/nodes/core/Node.js
var _nodeId = 0;
var Node = class {
  constructor(nodeType = null) {
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.None;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  get type() {
    return this.constructor.name;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getNodeType() {
    return this.nodeType;
  }
  update() {
    console.warn("Abstract function.");
  }
  generate() {
    console.warn("Abstract function.");
  }
  analyze(builder) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.analyze(builder);
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    const nodeKeys = getNodesKeys(this);
    for (const property2 of nodeKeys) {
      this[property2].analyze(builder);
    }
  }
  build(builder, output = null) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addStack(this);
    const nodeData = builder.getDataFromNode(this);
    const isGenerateOnce = this.generate.length === 1;
    let snippet = null;
    if (isGenerateOnce) {
      const type = this.getNodeType(builder);
      snippet = nodeData.snippet;
      if (snippet === void 0) {
        snippet = this.generate(builder) || "";
        nodeData.snippet = snippet;
      }
      snippet = builder.format(snippet, type, output);
    } else {
      snippet = this.generate(builder, output) || "";
    }
    builder.removeStack(this);
    return snippet;
  }
  serialize(json) {
    const nodeKeys = getNodesKeys(this);
    if (nodeKeys.length > 0) {
      const inputNodes = {};
      for (const property2 of nodeKeys) {
        inputNodes[property2] = this[property2].toJSON(json.meta).uuid;
      }
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        const uuid = json.inputNodes[property2];
        this[property2] = nodes[uuid];
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.5,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
Node.prototype.isNode = true;
var Node_default = Node;

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.value = value;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  serialize(data) {
    var _a, _b;
    super.serialize(data);
    data.value = ((_b = (_a = this.value) == null ? void 0 : _a.toArray) == null ? void 0 : _b.call(_a)) || this.value;
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
  }
  deserialize(data) {
    var _a, _b;
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = getValueFromType(data.valueType);
    this.value = ((_b = (_a = this.value) == null ? void 0 : _a.fromArray) == null ? void 0 : _b.call(_a, data.value)) || data.value;
  }
  generate() {
    console.warn("Abstract function.");
  }
};
InputNode.prototype.isInputNode = true;
var InputNode_default = InputNode;

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type, output);
  }
};
UniformNode.prototype.isUniformNode = true;
var UniformNode_default = UniformNode;

// node_modules/three/examples/jsm/nodes/core/VaryNode.js
var VaryNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const node = this.node;
    const name = this.name;
    const nodeVary = builder.getVaryFromNode(this, type);
    if (name !== null) {
      nodeVary.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVary, NodeShaderStage.Vertex);
    builder.flowNodeFromShaderStage(NodeShaderStage.Vertex, node, type, propertyName);
    return builder.getPropertyName(nodeVary);
  }
};
var VaryNode_default = VaryNode;

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attribute2 = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));
    if (builder.isShaderStage("vertex")) {
      return attribute2.name;
    } else {
      const nodeVary = new VaryNode_default(this);
      return nodeVary.build(builder, attribute2.type);
    }
  }
};
var AttributeNode_default = AttributeNode;

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
UVNode.prototype.isUVNode = true;
var UVNode_default = UVNode;

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = new UVNode_default(), biasNode = null) {
    super(value, "vec4");
    this.uvNode = uvNode;
    this.biasNode = biasNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getInputType() {
    return "texture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "texture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec2");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
TextureNode.prototype.isTextureNode = true;
var TextureNode_default = TextureNode;

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
BypassNode.prototype.isBypassNode = true;
var BypassNode_default = BypassNode;

// node_modules/three/examples/jsm/nodes/core/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", nodeType = "code") {
    super(nodeType);
    this.code = code2;
    this._includes = [];
  }
  setIncludes(includes) {
    this._includes = includes;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
};
CodeNode.prototype.isCodeNode = true;
var CodeNode_default = CodeNode;

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
ContextNode.prototype.isContextNode = true;
var ContextNode_default = ContextNode;

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
  }
  build(builder, output) {
    const type = builder.getVectorType(this.getNodeType(builder, output));
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.propertyName !== void 0) {
      return builder.format(nodeData.propertyName, type, output);
    } else if (builder.context.temp !== false && type !== "void " && output !== "void" && nodeData.dependenciesCount > 1) {
      const snippet = super.build(builder, type);
      const nodeVar = builder.getVarFromNode(this, type);
      const propertyName = builder.getPropertyName(nodeVar);
      builder.addFlowCode(`${propertyName} = ${snippet}`);
      nodeData.snippet = snippet;
      nodeData.propertyName = propertyName;
      return builder.format(nodeData.propertyName, type, output);
    }
    return super.build(builder, output);
  }
};
TempNode.prototype.isTempNode = true;
var TempNode_default = TempNode;

// node_modules/three/examples/jsm/nodes/core/ExpressionNode.js
var ExpressionNode = class extends TempNode_default {
  constructor(snipped = "", nodeType = "void") {
    super(nodeType);
    this.snipped = snipped;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const snipped = this.snipped;
    if (type === "void") {
      builder.addFlowCode(snipped);
    } else {
      return `( ${snipped} )`;
    }
  }
};
var ExpressionNode_default = ExpressionNode;

// node_modules/three/examples/jsm/nodes/core/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    for (const inputNode of inputs) {
      const node = parameters[inputNode.name];
      if (node !== void 0) {
        params.push(node.build(builder, inputNode.type));
      } else {
        throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;

// node_modules/three/examples/jsm/nodes/core/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "") {
    super(code2);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  call(parameters = {}) {
    return new FunctionCallNode_default(this, parameters);
  }
  generate(builder, output) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2;
    if (output === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output);
    }
  }
};
var FunctionNode_default = FunctionNode;

// node_modules/three/examples/jsm/nodes/core/InstanceIndexNode.js
var InstanceIndexNode = class extends Node_default {
  constructor() {
    super("uint");
  }
  generate(builder) {
    return builder.getInstanceIndex();
  }
};
InstanceIndexNode.prototype.isInstanceIndexNode = true;
var InstanceIndexNode_default = InstanceIndexNode;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(name = null, nodeType = "vec4") {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class _OperatorNode extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new _OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return "int";
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = builder.getTypeLength(output);
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addFlowCode(`${a} ${this.op} ${b}`);
        return a;
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a} ${this.op} ${b}`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  op(op, ...params) {
    this.node = new OperatorNode_default(op, this.node, ...params);
    return this;
  }
  assign(...params) {
    return this.op("=", ...params);
  }
  add(...params) {
    return this.op("+", ...params);
  }
  sub(...params) {
    return this.op("-", ...params);
  }
  mul(...params) {
    return this.op("*", ...params);
  }
  div(...params) {
    return this.op("/", ...params);
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const node = this.node;
    if (node.isTempNode === true) {
      return node.build(builder);
    }
    const name = this.name;
    const type = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, type);
    const nodeVar = builder.getVarFromNode(this, type);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
BufferNode.prototype.isBufferNode = true;
var BufferNode_default = BufferNode;

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var _Object3DNode = class _Object3DNode extends Node_default {
  constructor(scope = _Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.Object;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d !== null ? this.object3d : frame.object;
    const uniformNode = this._uniformNode;
    const camera = frame.camera;
    const scope = this.scope;
    if (scope === _Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION) {
      this._uniformNode.nodeType = "vec3";
      this._uniformNode.value = new Vector3();
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_Object3DNode, "VIEW_MATRIX", "viewMatrix");
__publicField(_Object3DNode, "NORMAL_MATRIX", "normalMatrix");
__publicField(_Object3DNode, "WORLD_MATRIX", "worldMatrix");
__publicField(_Object3DNode, "POSITION", "position");
__publicField(_Object3DNode, "VIEW_POSITION", "viewPosition");
var Object3DNode = _Object3DNode;
var Object3DNode_default = Object3DNode;

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var _CameraNode = class _CameraNode extends Object3DNode_default {
  constructor(scope = _CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === _CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
__publicField(_CameraNode, "PROJECTION_MATRIX", "projectionMatrix");
var CameraNode = _CameraNode;
var CameraNode_default = CameraNode;

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.Object;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    this.node = new UniformNode_default(null, uniformType);
    this.nodeType = uniformType;
    if (uniformType === "color") {
      this.nodeType = "vec3";
    } else if (uniformType === "texture") {
      this.nodeType = "vec4";
    }
  }
  getNodeType() {
    return this.uniformType;
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const value = object[this.property];
    this.node.value = value;
  }
  generate(builder) {
    return this.node.build(builder, this.getNodeType(builder));
  }
};
var ReferenceNode_default = ReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var _MaterialNode = class _MaterialNode extends Node_default {
  constructor(scope = _MaterialNode.COLOR) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === _MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === _MaterialNode.OPACITY) {
      return "float";
    } else if (scope === _MaterialNode.SPECULAR) {
      return "vec3";
    } else if (scope === _MaterialNode.ROUGHNESS || scope === _MaterialNode.METALNESS) {
      return "float";
    }
  }
  generate(builder, output) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.ALPHA_TEST) {
      node = new MaterialReferenceNode_default("alphaTest", "float");
    } else if (scope === _MaterialNode.COLOR) {
      const colorNode = new MaterialReferenceNode_default("color", "color");
      if (material.map !== null && material.map !== void 0 && material.map.isTexture === true) {
        node = new OperatorNode_default("*", colorNode, new MaterialReferenceNode_default("map", "texture"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = new MaterialReferenceNode_default("opacity", "float");
      if (material.alphaMap !== null && material.alphaMap !== void 0 && material.alphaMap.isTexture === true) {
        node = new OperatorNode_default("*", opacityNode, new MaterialReferenceNode_default("alphaMap", "texture"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR) {
      const specularColorNode = new MaterialReferenceNode_default("specularColor", "color");
      if (material.specularColorMap !== null && material.specularColorMap !== void 0 && material.specularColorMap.isTexture === true) {
        node = new OperatorNode_default("*", specularColorNode, new MaterialReferenceNode_default("specularColorMap", "texture"));
      } else {
        node = specularColorNode;
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode_default(scope, outputType);
    }
    return node.build(builder, output);
  }
};
__publicField(_MaterialNode, "ALPHA_TEST", "alphaTest");
__publicField(_MaterialNode, "COLOR", "color");
__publicField(_MaterialNode, "OPACITY", "opacity");
__publicField(_MaterialNode, "SPECULAR", "specular");
__publicField(_MaterialNode, "ROUGHNESS", "roughness");
__publicField(_MaterialNode, "METALNESS", "metalness");
var MaterialNode = _MaterialNode;
var MaterialNode_default = MaterialNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class _ModelNode extends Object3DNode_default {
  constructor(scope = _ModelNode.VIEW_MATRIX) {
    super(scope);
  }
};
var ModelNode_default = ModelNode;

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends Node_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (let i = 0; i < nodes.length; i++) {
      const input = nodes[i];
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    return `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
  }
};
var JoinNode_default = JoinNode;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.name = name;
    this.type = type;
    this.node = node;
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
NodeUniform.prototype.isNodeUniform = true;

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};
NodeAttribute.prototype.isNodeAttribute = true;

// node_modules/three/examples/jsm/nodes/core/NodeVary.js
var NodeVary = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};
NodeVary.prototype.isNodeVary = true;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};
NodeVar.prototype.isNodeVar = true;

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var defaultShaderStages = ["fragment", "vertex"];
var shaderStages = [...defaultShaderStages, "compute"];
var vector = ["x", "y", "z", "w"];
var typeFromLength = /* @__PURE__ */ new Map();
typeFromLength.set(1, "float");
typeFromLength.set(2, "vec2");
typeFromLength.set(3, "vec3");
typeFromLength.set(4, "vec4");
typeFromLength.set(9, "mat3");
typeFromLength.set(16, "mat4");

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type);
      return `${nodeSnippet}.${this.components}`;
    } else {
      return node.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var _MathNode = class _MathNode extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (isWebGL && (method === _MathNode.DFDX || method === _MathNode.DFDY) && output === "vec3") {
      return new JoinNode_default([
        new _MathNode(method, new SplitNode_default(a, "x")),
        new _MathNode(method, new SplitNode_default(a, "y")),
        new _MathNode(method, new SplitNode_default(a, "z"))
      ]).build(builder);
    } else if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode_default(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode_default(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode_default(new OperatorNode_default("*", tA, tB), "xyz");
      return new _MathNode(_MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === _MathNode.SATURATE) {
      return builder.format(`clamp( ${a.build(builder, inputType)}, 0.0, 1.0 )`, type, output);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( -" + a.build(builder, inputType) + " )", type, output);
    } else if (method === _MathNode.INVERT) {
      return builder.format("( 1.0 - " + a.build(builder, inputType) + " )", type, output);
    } else {
      const params = [];
      if (method === _MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (c !== null) {
          params.push(b.build(builder, inputType), c.build(builder, inputType));
        } else if (b !== null) {
          params.push(b.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
// 1 input
__publicField(_MathNode, "RADIANS", "radians");
__publicField(_MathNode, "DEGREES", "degrees");
__publicField(_MathNode, "EXP", "exp");
__publicField(_MathNode, "EXP2", "exp2");
__publicField(_MathNode, "LOG", "log");
__publicField(_MathNode, "LOG2", "log2");
__publicField(_MathNode, "SQRT", "sqrt");
__publicField(_MathNode, "INVERSE_SQRT", "inversesqrt");
__publicField(_MathNode, "FLOOR", "floor");
__publicField(_MathNode, "CEIL", "ceil");
__publicField(_MathNode, "NORMALIZE", "normalize");
__publicField(_MathNode, "FRACT", "fract");
__publicField(_MathNode, "SIN", "sin");
__publicField(_MathNode, "COS", "cos");
__publicField(_MathNode, "TAN", "tan");
__publicField(_MathNode, "ASIN", "asin");
__publicField(_MathNode, "ACOS", "acos");
__publicField(_MathNode, "ATAN", "atan");
__publicField(_MathNode, "ABS", "abs");
__publicField(_MathNode, "SIGN", "sign");
__publicField(_MathNode, "LENGTH", "length");
__publicField(_MathNode, "NEGATE", "negate");
__publicField(_MathNode, "INVERT", "invert");
__publicField(_MathNode, "DFDX", "dFdx");
__publicField(_MathNode, "DFDY", "dFdy");
__publicField(_MathNode, "SATURATE", "saturate");
__publicField(_MathNode, "ROUND", "round");
// 2 inputs
__publicField(_MathNode, "MIN", "min");
__publicField(_MathNode, "MAX", "max");
__publicField(_MathNode, "MOD", "mod");
__publicField(_MathNode, "STEP", "step");
__publicField(_MathNode, "REFLECT", "reflect");
__publicField(_MathNode, "DISTANCE", "distance");
__publicField(_MathNode, "DOT", "dot");
__publicField(_MathNode, "CROSS", "cross");
__publicField(_MathNode, "POW", "pow");
__publicField(_MathNode, "TRANSFORM_DIRECTION", "transformDirection");
// 3 inputs
__publicField(_MathNode, "MIX", "mix");
__publicField(_MathNode, "CLAMP", "clamp");
__publicField(_MathNode, "REFRACT", "refract");
__publicField(_MathNode, "SMOOTHSTEP", "smoothstep");
__publicField(_MathNode, "FACEFORWARD", "faceforward");
var MathNode = _MathNode;
var MathNode_default = MathNode;

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var _PositionNode = class _PositionNode extends Node_default {
  constructor(scope = _PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _PositionNode.GEOMETRY) {
      outputNode = new AttributeNode_default("position", "vec3");
    } else if (scope === _PositionNode.LOCAL) {
      outputNode = new VaryNode_default(new _PositionNode(_PositionNode.GEOMETRY));
    } else if (scope === _PositionNode.WORLD) {
      const vertexPositionNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new ModelNode_default(ModelNode_default.WORLD_MATRIX), new _PositionNode(_PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW) {
      const vertexPositionNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new _PositionNode(_PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new _PositionNode(_PositionNode.VIEW));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_PositionNode, "GEOMETRY", "geometry");
__publicField(_PositionNode, "LOCAL", "local");
__publicField(_PositionNode, "WORLD", "world");
__publicField(_PositionNode, "VIEW", "view");
__publicField(_PositionNode, "VIEW_DIRECTION", "viewDirection");
var PositionNode = _PositionNode;
var PositionNode_default = PositionNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends Node_default {
  constructor(position2 = new PositionNode_default()) {
    super("vec4");
    this.position = position2;
  }
  generate(builder) {
    const position2 = this.position;
    const mvpMatrix = new OperatorNode_default("*", new CameraNode_default(CameraNode_default.PROJECTION_MATRIX), new ModelNode_default(ModelNode_default.VIEW_MATRIX));
    const mvpNode = new OperatorNode_default("*", mvpMatrix, position2);
    return mvpNode.build(builder);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var _NormalNode = class _NormalNode extends Node_default {
  constructor(scope = _NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _NormalNode.GEOMETRY) {
      outputNode = new AttributeNode_default("normal", "vec3");
    } else if (scope === _NormalNode.LOCAL) {
      outputNode = new VaryNode_default(new _NormalNode(_NormalNode.GEOMETRY));
    } else if (scope === _NormalNode.VIEW) {
      const vertexNormalNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.NORMAL_MATRIX), new _NormalNode(_NormalNode.LOCAL));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    } else if (scope === _NormalNode.WORLD) {
      const vertexNormalNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new _NormalNode(_NormalNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_NormalNode, "GEOMETRY", "geometry");
__publicField(_NormalNode, "LOCAL", "local");
__publicField(_NormalNode, "WORLD", "world");
__publicField(_NormalNode, "VIEW", "view");
var NormalNode = _NormalNode;
var NormalNode_default = NormalNode;

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
PointUVNode.prototype.isPointUVNode = true;
var PointUVNode_default = PointUVNode;

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
  }
  getInputType() {
    return "storageBuffer";
  }
};
StorageBufferNode.prototype.isStorageBufferNode = true;
var StorageBufferNode_default = StorageBufferNode;

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
  }
  generate(builder) {
    return builder.getFrontFacing();
  }
};
FrontFacingNode.prototype.isFrontFacingNode = true;
var FrontFacingNode_default = FrontFacingNode;

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.updateType = NodeUpdateType.Object;
    this.updateDispatchCount();
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  update({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addFlowCode(snippet);
      }
    }
  }
};
ComputeNode.prototype.isComputeNode = true;
var ComputeNode_default = ComputeNode;

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    const elseType = this.elseNode.getNodeType(builder);
    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
      return elseType;
    }
    return ifType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const context2 = { temp: false };
    const nodeProperty = new PropertyNode_default(null, type).build(builder);
    const nodeSnippet = new ContextNode_default(
      this.condNode
      /*, context*/
    ).build(builder, "bool"), ifSnippet = new ContextNode_default(this.ifNode, context2).build(builder, type), elseSnippet = new ContextNode_default(this.elseNode, context2).build(builder, type);
    builder.addFlowCode(`if ( ${nodeSnippet} ) {

		${nodeProperty} = ${ifSnippet};

	} else {

		${nodeProperty} = ${elseSnippet};

	}`);
    return nodeProperty;
  }
};
var CondNode_default = CondNode;

// node_modules/three/examples/jsm/nodes/lights/ReflectedLightNode.js
var ReflectedLightNode = class extends Node_default {
  constructor() {
    super("vec3");
    this.directDiffuse = new VarNode_default(new UniformNode_default(new Vector3()), "DirectDiffuse");
    this.directSpecular = new VarNode_default(new UniformNode_default(new Vector3()), "DirectSpecular");
    this.indirectDiffuse = new VarNode_default(new UniformNode_default(new Vector3()), "IndirectDiffuse");
    this.indirectSpecular = new VarNode_default(new UniformNode_default(new Vector3()), "IndirectSpecular");
  }
  generate(builder) {
    const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = this;
    const totalLight = new OperatorNode_default("+", directDiffuse, directSpecular, indirectDiffuse, indirectSpecular);
    return totalLight.build(builder);
  }
};
var ReflectedLightNode_default = ReflectedLightNode;

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType() {
    return this.convertTo;
  }
  generate(builder) {
    const convertTo = this.convertTo;
    const node = this.node;
    if (builder.isReference(convertTo) === false) {
      const nodeSnippet = node.build(builder, convertTo);
      return builder.format(nodeSnippet, this.getNodeType(builder), convertTo);
    } else {
      return node.build(builder, convertTo);
    }
  }
};
var ConvertNode_default = ConvertNode;

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output);
  }
};
ConstNode.prototype.isConstNode = true;
var ConstNode_default = ConstNode;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var shaderNodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get: function(node, prop) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return nodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(node, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return node[prop];
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj) {
  const type = typeof obj;
  if (type === "number" || type === "boolean") {
    return nodeObject(getAutoTypedConstNode(obj));
  } else if (type === "object") {
    if ((obj == null ? void 0 : obj.isNode) === true) {
      let nodeObject2 = nodeObjectsCacheMap.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, shaderNodeHandler);
        nodeObjectsCacheMap.set(obj, nodeObject2);
        nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
var ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name]);
  }
  return objects;
};
var ShaderNodeArray = function(array) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i]);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null) {
  if (scope === null) {
    return (...params) => {
      return nodeObject(new NodeClass(...nodeArray(params)));
    };
  } else if (factor === null) {
    return (...params) => {
      return nodeObject(new NodeClass(scope, ...nodeArray(params)));
    };
  } else {
    factor = nodeObject(factor);
    return (...params) => {
      return nodeObject(new NodeClass(scope, ...nodeArray(params), factor));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderNodeScript = function(jsFunc) {
  const self = {
    build: (builder) => {
      self.call({}, builder);
      return "";
    },
    call: (inputs, builder) => {
      inputs = nodeObjects(inputs);
      return nodeObject(jsFunc(inputs, builder));
    }
  };
  return self;
};
var ShaderNode = new Proxy(ShaderNodeScript, shaderNodeHandler);
var nodeObject = (val) => (
  /* new */
  ShaderNodeObject(val)
);
var nodeObjects = (val) => new ShaderNodeObjects(val);
var nodeArray = (val) => new ShaderNodeArray(val);
var nodeProxy = (...val) => new ShaderNodeProxy(...val);
var nodeImmutable = (...val) => new ShaderNodeImmutable(...val);
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (let bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (let uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (let int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (let float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (let float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value);
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode_default(getValueFromType(type), type));
    } else {
      if (type === "color" && params[0].isNode !== true) {
        params = [getValueFromType(type, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      if (nodes.length === 1) {
        return nodeObject(nodes[0].nodeType === type ? nodes[0] : new ConvertNode_default(nodes[0], type));
      }
      return nodeObject(new ConvertNode_default(new JoinNode_default(nodes), type));
    }
  };
};
var getConstNodeType = (value) => value.nodeType || value.convertTo || (typeof value === "string" ? value : null);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeBaseElements.js
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.int);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var func = (code2) => {
  const node = nodeObject(new FunctionNode_default(code2));
  const call2 = node.call.bind(node);
  node.call = (params) => nodeObject(call2(params));
  return node;
};
var uniform = (nodeOrType) => {
  var _a;
  const nodeType = getConstNodeType(nodeOrType);
  const value = nodeOrType.isNode === true ? ((_a = nodeOrType.node) == null ? void 0 : _a.value) || nodeOrType.value : nodeOrType;
  return nodeObject(new UniformNode_default(value, nodeType));
};
var attribute = (name, nodeOrType) => nodeObject(new AttributeNode_default(name, getConstNodeType(nodeOrType)));
var property = (name, nodeOrType) => nodeObject(new PropertyNode_default(name, getConstNodeType(nodeOrType)));
var bypass = nodeProxy(BypassNode_default);
var code = nodeProxy(CodeNode_default);
var context = nodeProxy(ContextNode_default);
var expression = nodeProxy(ExpressionNode_default);
var call = nodeProxy(FunctionCallNode_default);
var instanceIndex = nodeImmutable(InstanceIndexNode_default);
var label = nodeProxy(VarNode_default);
var temp = label;
var vary = nodeProxy(VaryNode_default);
var buffer = (value, nodeOrType, count) => nodeObject(new BufferNode_default(value, getConstNodeType(nodeOrType), count));
var storage = (value, nodeOrType, count) => nodeObject(new StorageBufferNode_default(value, getConstNodeType(nodeOrType), count));
var cameraProjectionMatrix = nodeImmutable(CameraNode_default, CameraNode_default.PROJECTION_MATRIX);
var cameraViewMatrix = nodeImmutable(CameraNode_default, CameraNode_default.VIEW_MATRIX);
var cameraNormalMatrix = nodeImmutable(CameraNode_default, CameraNode_default.NORMAL_MATRIX);
var cameraWorldMatrix = nodeImmutable(CameraNode_default, CameraNode_default.WORLD_MATRIX);
var cameraPosition = nodeImmutable(CameraNode_default, CameraNode_default.POSITION);
var materialAlphaTest = nodeImmutable(MaterialNode_default, MaterialNode_default.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode_default, MaterialNode_default.COLOR);
var materialOpacity = nodeImmutable(MaterialNode_default, MaterialNode_default.OPACITY);
var materialSpecular = nodeImmutable(MaterialNode_default, MaterialNode_default.SPECULAR);
var materialRoughness = nodeImmutable(MaterialNode_default, MaterialNode_default.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode_default, MaterialNode_default.METALNESS);
var diffuseColor = nodeImmutable(PropertyNode_default, "DiffuseColor", "vec4");
var roughness = nodeImmutable(PropertyNode_default, "Roughness", "float");
var metalness = nodeImmutable(PropertyNode_default, "Metalness", "float");
var alphaTest = nodeImmutable(PropertyNode_default, "AlphaTest", "float");
var specularColor = nodeImmutable(PropertyNode_default, "SpecularColor", "color");
var reference = (name, nodeOrType, object) => nodeObject(new ReferenceNode_default(name, getConstNodeType(nodeOrType), object));
var materialReference = (name, nodeOrType, material) => nodeObject(new MaterialReferenceNode_default(name, getConstNodeType(nodeOrType), material));
var modelViewProjection = nodeProxy(ModelViewProjectionNode_default);
var normalGeometry = nodeImmutable(NormalNode_default, NormalNode_default.GEOMETRY);
var normalLocal = nodeImmutable(NormalNode_default, NormalNode_default.LOCAL);
var normalWorld = nodeImmutable(NormalNode_default, NormalNode_default.WORLD);
var normalView = nodeImmutable(NormalNode_default, NormalNode_default.VIEW);
var transformedNormalView = nodeImmutable(VarNode_default, normalView, "TransformedNormalView");
var viewMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.VIEW_MATRIX);
var normalMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.NORMAL_MATRIX);
var worldMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.WORLD_MATRIX);
var position = nodeProxy(Object3DNode_default, Object3DNode_default.POSITION);
var viewPosition = nodeProxy(Object3DNode_default, Object3DNode_default.VIEW_POSITION);
var positionGeometry = nodeImmutable(PositionNode_default, PositionNode_default.GEOMETRY);
var positionLocal = nodeImmutable(PositionNode_default, PositionNode_default.LOCAL);
var positionWorld = nodeImmutable(PositionNode_default, PositionNode_default.WORLD);
var positionView = nodeImmutable(PositionNode_default, PositionNode_default.VIEW);
var positionViewDirection = nodeImmutable(PositionNode_default, PositionNode_default.VIEW_DIRECTION);
var texture = nodeProxy(TextureNode_default);
var sampler = (texture2) => nodeObject(new ConvertNode_default(texture2.isNode === true ? texture2 : new TextureNode_default(texture2), "sampler"));
var uv = (...params) => nodeObject(new UVNode_default(...params));
var pointUV = nodeImmutable(PointUVNode_default);
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode_default(nodeObject(node), count, workgroupSize));
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var cond = nodeProxy(CondNode_default);
var add = nodeProxy(OperatorNode_default, "+");
var sub = nodeProxy(OperatorNode_default, "-");
var mul = nodeProxy(OperatorNode_default, "*");
var div = nodeProxy(OperatorNode_default, "/");
var remainder = nodeProxy(OperatorNode_default, "%");
var equal = nodeProxy(OperatorNode_default, "==");
var assign = nodeProxy(OperatorNode_default, "=");
var lessThan = nodeProxy(OperatorNode_default, "<");
var greaterThan = nodeProxy(OperatorNode_default, ">");
var lessThanEqual = nodeProxy(OperatorNode_default, "<=");
var greaterThanEqual = nodeProxy(OperatorNode_default, ">=");
var and = nodeProxy(OperatorNode_default, "&&");
var or = nodeProxy(OperatorNode_default, "||");
var xor = nodeProxy(OperatorNode_default, "^^");
var bitAnd = nodeProxy(OperatorNode_default, "&");
var bitOr = nodeProxy(OperatorNode_default, "|");
var bitXor = nodeProxy(OperatorNode_default, "^");
var shiftLeft = nodeProxy(OperatorNode_default, "<<");
var shiftRight = nodeProxy(OperatorNode_default, ">>");
var radians = nodeProxy(MathNode_default, MathNode_default.RADIANS);
var degrees = nodeProxy(MathNode_default, MathNode_default.DEGREES);
var exp = nodeProxy(MathNode_default, MathNode_default.EXP);
var exp2 = nodeProxy(MathNode_default, MathNode_default.EXP2);
var log = nodeProxy(MathNode_default, MathNode_default.LOG);
var log2 = nodeProxy(MathNode_default, MathNode_default.LOG2);
var sqrt = nodeProxy(MathNode_default, MathNode_default.SQRT);
var inversesqrt = nodeProxy(MathNode_default, MathNode_default.INVERSE_SQRT);
var floor = nodeProxy(MathNode_default, MathNode_default.FLOOR);
var ceil = nodeProxy(MathNode_default, MathNode_default.CEIL);
var normalize = nodeProxy(MathNode_default, MathNode_default.NORMALIZE);
var fract = nodeProxy(MathNode_default, MathNode_default.FRACT);
var sin = nodeProxy(MathNode_default, MathNode_default.SIN);
var cos = nodeProxy(MathNode_default, MathNode_default.COS);
var tan = nodeProxy(MathNode_default, MathNode_default.TAN);
var asin = nodeProxy(MathNode_default, MathNode_default.ASIN);
var acos = nodeProxy(MathNode_default, MathNode_default.ACOS);
var atan = nodeProxy(MathNode_default, MathNode_default.ATAN);
var abs = nodeProxy(MathNode_default, MathNode_default.ABS);
var sign = nodeProxy(MathNode_default, MathNode_default.SIGN);
var length = nodeProxy(MathNode_default, MathNode_default.LENGTH);
var negate = nodeProxy(MathNode_default, MathNode_default.NEGATE);
var invert = nodeProxy(MathNode_default, MathNode_default.INVERT);
var dFdx = nodeProxy(MathNode_default, MathNode_default.DFDX);
var dFdy = nodeProxy(MathNode_default, MathNode_default.DFDY);
var saturate = nodeProxy(MathNode_default, MathNode_default.SATURATE);
var round = nodeProxy(MathNode_default, MathNode_default.ROUND);
var min = nodeProxy(MathNode_default, MathNode_default.MIN);
var max = nodeProxy(MathNode_default, MathNode_default.MAX);
var mod = nodeProxy(MathNode_default, MathNode_default.MOD);
var step = nodeProxy(MathNode_default, MathNode_default.STEP);
var reflect = nodeProxy(MathNode_default, MathNode_default.REFLECT);
var distance = nodeProxy(MathNode_default, MathNode_default.DISTANCE);
var dot = nodeProxy(MathNode_default, MathNode_default.DOT);
var cross = nodeProxy(MathNode_default, MathNode_default.CROSS);
var pow = nodeProxy(MathNode_default, MathNode_default.POW);
var pow2 = nodeProxy(MathNode_default, MathNode_default.POW, 2);
var pow3 = nodeProxy(MathNode_default, MathNode_default.POW, 3);
var pow4 = nodeProxy(MathNode_default, MathNode_default.POW, 4);
var transformDirection = nodeProxy(MathNode_default, MathNode_default.TRANSFORM_DIRECTION);
var mix = nodeProxy(MathNode_default, MathNode_default.MIX);
var clamp = nodeProxy(MathNode_default, MathNode_default.CLAMP);
var refract = nodeProxy(MathNode_default, MathNode_default.REFRACT);
var smoothstep = nodeProxy(MathNode_default, MathNode_default.SMOOTHSTEP);
var faceforward = nodeProxy(MathNode_default, MathNode_default.FACEFORWARD);
var frontFacing = nodeImmutable(FrontFacingNode_default);
var faceDirection = sub(mul(float(frontFacing), 2), 1);
var reflectedLight = nodeProxy(ReflectedLightNode_default);
var element = nodeProxy(ArrayElementNode_default);
var dotNV = saturate(dot(transformedNormalView, positionViewDirection));

// node_modules/three/examples/jsm/nodes/accessors/ReflectNode.js
var _ReflectNode = class _ReflectNode extends Node_default {
  constructor(scope = _ReflectNode.CUBE) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `reflect-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _ReflectNode.VECTOR) {
      const cameraToFrag = normalize(sub(positionWorld, cameraPosition));
      const reflectVec = reflect(cameraToFrag, normalWorld);
      return reflectVec.build(builder);
    } else if (scope === _ReflectNode.CUBE) {
      const reflectVec = nodeObject(new _ReflectNode(_ReflectNode.VECTOR));
      const cubeUV = vec3(negate(reflectVec.x), reflectVec.yz);
      return cubeUV.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_ReflectNode, "VECTOR", "vector");
__publicField(_ReflectNode, "CUBE", "cube");
var ReflectNode = _ReflectNode;
var ReflectNode_default = ReflectNode;

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = new ReflectNode_default(), biasNode = null) {
    super(value, uvNode, biasNode);
  }
  getInputType() {
    return "cubeTexture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec3");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getCubeTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getCubeTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
};
CubeTextureNode.prototype.isCubeTextureNode = true;
var CubeTextureNode_default = CubeTextureNode;

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    const instanceBufferNode = buffer(instanceMesh.instanceMatrix.array, "mat4", instanceMesh.count);
    this.instanceMatrixNode = temp(element(instanceBufferNode, instanceIndex));
  }
  generate(builder) {
    const { instanceMatrixNode } = this;
    const instancePosition = mul(instanceMatrixNode, positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = div(normalLocal, vec3(dot(m[0], m[0]), dot(m[1], m[1]), dot(m[2], m[2])));
    const instanceNormal = mul(m, transformedNormal).xyz;
    assign(positionLocal, instancePosition).build(builder);
    assign(normalLocal, instanceNormal).build(builder);
  }
};
var InstanceNode_default = InstanceNode;

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var Skinning = new ShaderNode((inputs, builder) => {
  const { index, weight, bindMatrix, bindMatrixInverse, boneMatrices } = inputs;
  const boneMatX = element(boneMatrices, index.x);
  const boneMatY = element(boneMatrices, index.y);
  const boneMatZ = element(boneMatrices, index.z);
  const boneMatW = element(boneMatrices, index.w);
  const skinVertex = mul(bindMatrix, positionLocal);
  const skinned = add(
    mul(mul(boneMatX, skinVertex), weight.x),
    mul(mul(boneMatY, skinVertex), weight.y),
    mul(mul(boneMatZ, skinVertex), weight.z),
    mul(mul(boneMatW, skinVertex), weight.w)
  );
  const skinPosition = mul(bindMatrixInverse, skinned).xyz;
  let skinMatrix = add(
    mul(weight.x, boneMatX),
    mul(weight.y, boneMatY),
    mul(weight.z, boneMatZ),
    mul(weight.w, boneMatW)
  );
  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);
  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz;
  assign(positionLocal, skinPosition).build(builder);
  assign(normalLocal, skinNormal).build(builder);
});
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.Object;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = uniform(mat4(skinnedMesh.bindMatrix));
    this.bindMatrixInverseNode = uniform(mat4(skinnedMesh.bindMatrixInverse));
    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  }
  generate(builder) {
    Skinning.call({
      index: this.skinIndexNode,
      weight: this.skinWeightNode,
      bindMatrix: this.bindMatrixNode,
      bindMatrixInverse: this.bindMatrixInverseNode,
      boneMatrices: this.boneMatricesNode
    }, builder);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var LinearToLinear = new ShaderNode((inputs) => {
  return inputs.value;
});
var LinearTosRGB = new ShaderNode((inputs) => {
  const { value } = inputs;
  const rgb = value.rgb;
  const a = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));
  const b = mul(rgb, 12.92);
  const factor = vec3(lessThanEqual(rgb, vec3(31308e-7)));
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
var _ColorSpaceNode = class _ColorSpaceNode extends Node_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromEncoding(encoding) {
    let method = null;
    if (encoding === LinearEncoding) {
      method = "Linear";
    } else if (encoding === sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const method = this.method;
    const node = this.node;
    if (method !== _ColorSpaceNode.LINEAR_TO_LINEAR) {
      const encodingFunctionNode = EncodingLib[method];
      return encodingFunctionNode.call({
        value: node
      }).build(builder, type);
    } else {
      return node.build(builder, type);
    }
  }
};
__publicField(_ColorSpaceNode, "LINEAR_TO_LINEAR", "LinearToLinear");
__publicField(_ColorSpaceNode, "LINEAR_TO_SRGB", "LinearTosRGB");
var ColorSpaceNode = _ColorSpaceNode;
var ColorSpaceNode_default = ColorSpaceNode;

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2ArbNode = new ShaderNode((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = dFdx(eye_pos.xyz);
  const q1 = dFdy(eye_pos.xyz);
  const st0 = dFdx(uv2.st);
  const st1 = dFdy(uv2.st);
  const N = surf_norm;
  const q1perp = cross(q1, N);
  const q0perp = cross(N, q0);
  const T = add(mul(q1perp, st0.x), mul(q0perp, st1.x));
  const B = add(mul(q1perp, st0.y), mul(q0perp, st1.y));
  const det = max(dot(T, T), dot(B, B));
  const scale = cond(equal(det, 0), 0, mul(faceDirection, inversesqrt(det)));
  return normalize(add(mul(T, mul(mapN.x, scale)), mul(B, mul(mapN.y, scale)), mul(N, mapN.z)));
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const { normalMapType, scaleNode } = this;
    const normalOP = mul(this.node, 2);
    let normalMap2 = sub(normalOP, 1);
    if (scaleNode !== null) {
      const normalMapScale = mul(normalMap2.xy, scaleNode);
      normalMap2 = vec3(normalMapScale, normalMap2.z);
    }
    if (normalMapType === ObjectSpaceNormalMap) {
      const vertexNormalNode = mul(new ModelNode_default(ModelNode_default.NORMAL_MATRIX), normalMap2);
      const normal = normalize(vertexNormalNode);
      return normal.build(builder, type);
    } else if (normalMapType === TangentSpaceNormalMap) {
      const perturbNormal2ArbCall = perturbNormal2ArbNode.call({
        eye_pos: positionView,
        surf_norm: normalView,
        mapN: normalMap2,
        uv: uv()
      });
      return perturbNormal2ArbCall.build(builder, type);
    }
  }
};
var NormalMapNode_default = NormalMapNode;

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  return mul(color2, exposure);
});
var ToneMappingNode = class extends Node_default {
  constructor(toneMapping2, exposureNode = float(1), colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const colorNode = this.color || builder.context.color;
    const toneMapping2 = this.toneMapping;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    if (toneMapping2 === LinearToneMapping) {
      return LinearToneMappingNode.call(toneMappingParams).build(builder, type);
    } else {
      return this.colorNode.build(builder, type);
    }
  }
};
var ToneMappingNode_default = ToneMappingNode;

// node_modules/three/examples/jsm/nodes/functions/light/getDistanceAttenuation.js
var getDistanceAttenuation = new ShaderNode((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = div(1, max(pow(lightDistance, decayExponent), 0.01));
  return cond(
    greaterThan(cutoffDistance, 0),
    mul(distanceFalloff, pow2(saturate(sub(1, pow4(div(lightDistance, cutoffDistance)))))),
    distanceFalloff
  );
});
var getDistanceAttenuation_default = getDistanceAttenuation;

// node_modules/three/examples/jsm/nodes/lights/LightNode.js
var LightNode = class extends Node_default {
  constructor(light2 = null) {
    super("vec3");
    this.updateType = NodeUpdateType.Object;
    this.light = light2;
    this._colorNode = new UniformNode_default(new Color());
    this._lightCutoffDistanceNode = new UniformNode_default(0);
    this._lightDecayExponentNode = new UniformNode_default(0);
  }
  getHash() {
    return this.light.uuid;
  }
  update() {
    this._colorNode.value.copy(this.light.color).multiplyScalar(this.light.intensity);
    this._lightCutoffDistanceNode.value = this.light.distance;
    this._lightDecayExponentNode.value = this.light.decay;
  }
  generate(builder) {
    const lightPositionView = new Object3DNode_default(Object3DNode_default.VIEW_POSITION);
    const positionView2 = new PositionNode_default(PositionNode_default.VIEW);
    const lVector = new OperatorNode_default("-", lightPositionView, positionView2);
    const lightDirection = new MathNode_default(MathNode_default.NORMALIZE, lVector);
    const lightDistance = new MathNode_default(MathNode_default.LENGTH, lVector);
    const lightAttenuation = getDistanceAttenuation_default.call({
      lightDistance,
      cutoffDistance: this._lightCutoffDistanceNode,
      decayExponent: this._lightDecayExponentNode
    });
    const lightColor = new OperatorNode_default("*", this._colorNode, lightAttenuation);
    lightPositionView.object3d = this.light;
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    if (lightingModelFunctionNode !== void 0) {
      const reflectedLight2 = builder.context.reflectedLight;
      lightingModelFunctionNode.call({
        lightDirection,
        lightColor,
        reflectedLight: reflectedLight2
      }, builder);
    }
  }
};
var LightNode_default = LightNode;

// node_modules/three/examples/jsm/nodes/lights/LightsNode.js
var sortLights = (lights) => {
  return lights.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  generate(builder) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
    return "vec3( 0.0 )";
  }
  getHash() {
    if (this._hash === null) {
      let hash = "";
      const lightNodes = this.lightNodes;
      for (const lightNode of lightNodes) {
        hash += lightNode.light.uuid + " ";
      }
      this._hash = hash;
    }
    return this._hash;
  }
  getLightNodeByHash(hash) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      if (lightNode.light.uuid === hash) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights) {
    const lightNodes = [];
    lights = sortLights(lights);
    for (const light2 of lights) {
      let lightNode = this.getLightNodeByHash(light2.uuid);
      if (lightNode === null) {
        lightNode = new LightNode_default(light2);
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
};
var LightsNode_default = LightsNode;

// node_modules/three/examples/jsm/nodes/lights/LightContextNode.js
var LightContextNode = class extends ContextNode_default {
  constructor(node, lightingModelNode = null) {
    super(node);
    this.lightingModelNode = lightingModelNode;
  }
  getNodeType() {
    return "vec3";
  }
  generate(builder) {
    const { lightingModelNode } = this;
    this.context.reflectedLight = reflectedLight();
    if (lightingModelNode !== null) {
      this.context.lightingModelNode = lightingModelNode;
    }
    const type = this.getNodeType(builder);
    super.generate(builder, type);
    return this.context.reflectedLight.build(builder, type);
  }
};
var LightContextNode_default = LightContextNode;

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  generate(builder) {
    const x = normalize(vec3(positionViewDirection.z, 0, negate(positionViewDirection.x)));
    const y = cross(positionViewDirection, x);
    const uv2 = add(mul(vec2(dot(x, transformedNormalView), dot(y, transformedNormalView)), 0.495), 0.5);
    return uv2.build(builder, this.getNodeType(builder));
  }
};
var MatcapUVNode_default = MatcapUVNode;

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(texture2) {
    super(0);
    this.texture = texture2;
    this.updateType = NodeUpdateType.Frame;
  }
  update() {
    const { width, height } = this.texture.images ? this.texture.images[0] : this.texture.image;
    this.value = Math.log(Math.max(width, height)) * Math.LOG2E;
    if (this.value > 0) {
      this.updateType = NodeUpdateType.None;
    }
  }
};
var MaxMipLevelNode_default = MaxMipLevelNode;

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var _TimerNode = class _TimerNode extends UniformNode_default {
  constructor(scope = _TimerNode.LOCAL) {
    super(0);
    this.scope = scope;
    this.scale = 1;
    this.updateType = NodeUpdateType.Frame;
  }
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === _TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === _TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
__publicField(_TimerNode, "LOCAL", "local");
__publicField(_TimerNode, "GLOBAL", "global");
__publicField(_TimerNode, "DELTA", "delta");
var TimerNode = _TimerNode;
var TimerNode_default = TimerNode;

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var _OscNode = class _OscNode extends Node_default {
  constructor(method = _OscNode.SINE, timeNode = new TimerNode_default()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  generate(builder) {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = round(fract(timeNode));
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = fract(timeNode);
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
__publicField(_OscNode, "SINE", "sine");
__publicField(_OscNode, "SQUARE", "square");
__publicField(_OscNode, "TRIANGLE", "triangle");
__publicField(_OscNode, "SAWTOOTH", "sawtooth");
var OscNode = _OscNode;
var OscNode_default = OscNode;

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = new UVNode_default(), frameNode = new ConstNode_default(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  generate(builder) {
    const count = this.countNode;
    const uv2 = this.uvNode;
    const frame = this.frameNode;
    const one = new ConstNode_default(1);
    const width = new SplitNode_default(count, "x");
    const height = new SplitNode_default(count, "y");
    const total = new OperatorNode_default("*", width, height);
    const roundFrame = new MathNode_default(MathNode_default.FLOOR, new MathNode_default(MathNode_default.MOD, frame, total));
    const frameNum = new OperatorNode_default("+", roundFrame, one);
    const cell = new MathNode_default(MathNode_default.MOD, roundFrame, width);
    const row = new MathNode_default(MathNode_default.CEIL, new OperatorNode_default("/", frameNum, width));
    const rowInv = new OperatorNode_default("-", height, row);
    const scale = new OperatorNode_default("/", one, count);
    const uvFrameOffset = new JoinNode_default([
      new OperatorNode_default("*", cell, new SplitNode_default(scale, "x")),
      new OperatorNode_default("*", rowInv, new SplitNode_default(scale, "y"))
    ]);
    const uvScale = new OperatorNode_default("*", uv2, scale);
    const uvFrame = new OperatorNode_default("+", uvScale, uvFrameOffset);
    return uvFrame.build(builder, this.getNodeType(builder));
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = new ShaderNode((inputs) => {
  const uv2 = mul(inputs.uv, 2);
  const cx = floor(uv2.x);
  const cy = floor(uv2.y);
  const result = mod(add(cx, cy), 2);
  return sign(result);
});
var CheckerNode = class extends Node_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  generate(builder) {
    return checkerShaderNode.call({ uv: this.uvNode }).build(builder);
  }
};
var CheckerNode_default = CheckerNode;

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  mix(outputNode) {
    return new MathNode_default(MathNode_default.MIX, outputNode, this.colorNode, this);
  }
  generate(builder) {
    return this.factorNode.build(builder, "float");
  }
};
FogNode.prototype.isFogNode = true;
var FogNode_default = FogNode;

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  generate(builder) {
    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));
    return super.generate(builder);
  }
};
FogRangeNode.prototype.isFogRangeNode = true;
var FogRangeNode_default = FogRangeNode;

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = new ShaderNode((inputs) => {
  const { f0, f90, dotVH } = inputs;
  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));
  return add(mul(f0, sub(1, fresnel)), mul(f90, fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const { alpha, dotNL, dotNV: dotNV2 } = inputs;
  const a2 = pow2(alpha);
  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1, a2), pow2(dotNV2)))));
  const gl = mul(dotNV2, sqrt(add(a2, mul(sub(1, a2), pow2(dotNL)))));
  return div(0.5, max(add(gv, gl), EPSILON));
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = new ShaderNode((inputs) => {
  const { alpha, dotNH } = inputs;
  const a2 = pow2(alpha);
  const denom = add(mul(pow2(dotNH), sub(a2, 1)), 1);
  return mul(1 / Math.PI, div(a2, pow2(denom)));
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = new ShaderNode((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2 } = inputs;
  const alpha = pow2(roughness2);
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const dotNH = saturate(dot(transformedNormalView, halfDir));
  const dotVH = saturate(dot(positionViewDirection, halfDir));
  const F = F_Schlick_default.call({ f0, f90, dotVH });
  const V = V_GGX_SmithCorrelated_default.call({ alpha, dotNL, dotNV });
  const D = D_GGX_default.call({ alpha, dotNH });
  return mul(F, mul(V, D));
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = new ShaderNode((inputs) => {
  return mul(1 / Math.PI, inputs.diffuseColor);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = new ShaderNode(() => {
  const dxy = max(abs(dFdx(normalGeometry)), abs(dFdy(normalGeometry)));
  const geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = new ShaderNode((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default.call();
  let roughnessFactor = max(roughness2, 0.0525);
  roughnessFactor = add(roughnessFactor, geometryRoughness);
  roughnessFactor = min(roughnessFactor, 1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var RE_Direct_Physical = new ShaderNode((inputs) => {
  const { lightDirection, lightColor, reflectedLight: reflectedLight2 } = inputs;
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const irradiance = mul(dotNL, lightColor);
  reflectedLight2.directSpecular.add(mul(irradiance, BRDF_GGX_default.call({ lightDirection, f0: specularColor, f90: 1, roughness })));
  reflectedLight2.directDiffuse.add(mul(irradiance, BRDF_Lambert_default.call({ diffuseColor: diffuseColor.rgb })));
});
var PhysicalLightingModel = new ShaderNode((inputs) => {
  RE_Direct_Physical.call(inputs);
});
var PhysicalLightingModel_default = PhysicalLightingModel;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeElements.js
var cubeTexture = nodeProxy(CubeTextureNode_default);
var instance = nodeProxy(InstanceNode_default);
var reflectVector = nodeImmutable(ReflectNode_default, ReflectNode_default.VECTOR);
var reflectCube = nodeImmutable(ReflectNode_default, ReflectNode_default.CUBE);
var skinning = nodeProxy(SkinningNode_default);
var colorSpace = (node, encoding) => nodeObject(new ColorSpaceNode_default(null, nodeObject(node)).fromEncoding(encoding));
var normalMap = nodeProxy(NormalMapNode_default);
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode_default(mapping, nodeObject(exposure), nodeObject(color2)));
var light = nodeProxy(LightNode_default);
var fromLights = (lights) => nodeObject(new LightsNode_default().fromLights(lights));
var lightContext = nodeProxy(LightContextNode_default);
var matcapUV = nodeImmutable(MatcapUVNode_default);
var maxMipLevel = nodeProxy(MaxMipLevelNode_default);
var oscSine = nodeProxy(OscNode_default, OscNode_default.SINE);
var oscSquare = nodeProxy(OscNode_default, OscNode_default.SQUARE);
var oscTriangle = nodeProxy(OscNode_default, OscNode_default.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode_default, OscNode_default.SAWTOOTH);
var spritesheetUV = nodeProxy(SpriteSheetUVNode_default);
var timerLocal = nodeImmutable(TimerNode_default, TimerNode_default.LOCAL);
var timerGlobal = nodeImmutable(TimerNode_default, TimerNode_default.GLOBAL);
var timerDelta = nodeImmutable(TimerNode_default, TimerNode_default.DELTA);
var checker = nodeProxy(CheckerNode_default);
var fog = nodeProxy(FogNode_default);
var rangeFog = nodeProxy(FogRangeNode_default);
export {
  BRDF_GGX_default as BRDF_GGX,
  BRDF_Lambert_default as BRDF_Lambert,
  D_GGX_default as D_GGX,
  EPSILON,
  F_Schlick_default as F_Schlick,
  INFINITY,
  PhysicalLightingModel_default as PhysicalLightingModel,
  ShaderNode,
  V_GGX_SmithCorrelated_default as V_GGX_SmithCorrelated,
  abs,
  acos,
  add,
  alphaTest,
  and,
  asin,
  assign,
  atan,
  attribute,
  bitAnd,
  bitOr,
  bitXor,
  bmat3,
  bmat4,
  bool,
  buffer,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  call,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  checker,
  clamp,
  code,
  color,
  colorSpace,
  compute,
  cond,
  context,
  cos,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  degrees,
  diffuseColor,
  distance,
  div,
  dot,
  dotNV,
  element,
  equal,
  exp,
  exp2,
  expression,
  faceDirection,
  faceforward,
  float,
  floor,
  fog,
  fract,
  fromLights,
  frontFacing,
  func,
  getDistanceAttenuation_default as getDistanceAttenuation,
  getGeometryRoughness_default as getGeometryRoughness,
  getRoughness_default as getRoughness,
  greaterThan,
  greaterThanEqual,
  imat3,
  imat4,
  instance,
  instanceIndex,
  int,
  inversesqrt,
  invert,
  ivec2,
  ivec3,
  ivec4,
  label,
  length,
  lessThan,
  lessThanEqual,
  light,
  lightContext,
  log,
  log2,
  mat3,
  mat4,
  matcapUV,
  materialAlphaTest,
  materialColor,
  materialMetalness,
  materialOpacity,
  materialReference,
  materialRoughness,
  materialSpecular,
  max,
  maxMipLevel,
  metalness,
  min,
  mix,
  mod,
  modelViewProjection,
  mul,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMap,
  normalMatrix,
  normalView,
  normalWorld,
  normalize,
  or,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  pointUV,
  position,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  rangeFog,
  reference,
  reflect,
  reflectCube,
  reflectVector,
  reflectedLight,
  refract,
  remainder,
  roughness,
  round,
  sampler,
  saturate,
  shiftLeft,
  shiftRight,
  sign,
  sin,
  skinning,
  smoothstep,
  specularColor,
  spritesheetUV,
  sqrt,
  step,
  storage,
  sub,
  tan,
  temp,
  texture,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  transformDirection,
  transformedNormalView,
  uint,
  umat3,
  umat4,
  uniform,
  uv,
  uvec2,
  uvec3,
  uvec4,
  vary,
  vec2,
  vec3,
  vec4,
  viewMatrix,
  viewPosition,
  worldMatrix,
  xor
};
//# sourceMappingURL=three_examples_jsm_nodes_shadernode_ShaderNodeElements.js.map
