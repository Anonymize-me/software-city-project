{
  "version": 3,
  "sources": ["../../bin-pack/packer.growing.js", "../../bin-pack/index.js"],
  "sourcesContent": ["/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n\tblocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n\tmarks each block that fits with a .fit attribute pointing to a\n\tnode with .x and .y coordinates\n\nExample:\n-------\n\n\tvar blocks = [\n\t\t{ w: 100, h: 100 },\n\t\t{ w: 100, h: 100 },\n\t\t{ w:  80, h:  80 },\n\t\t{ w:  80, h:  80 },\n\t\tetc\n\t\tetc\n\t];\n\n\tvar packer = new GrowingPacker();\n\tpacker.fit(blocks);\n\n\tfor(var n = 0 ; n < blocks.length ; n++) {\n\t\tvar block = blocks[n];\n\t\tif (block.fit) {\n\t\t\tDraw(block.fit.x, block.fit.y, block.w, block.h);\n\t\t}\n\t}\n\n\n******************************************************************************/\n\nvar GrowingPacker = function() { };\n\nGrowingPacker.prototype = {\n\n\tfit: function(blocks) {\n\t\tvar n, node, block, len = blocks.length, fit;\n\t\tvar width  = len > 0 ? blocks[0].width : 0;\n\t\tvar height = len > 0 ? blocks[0].height : 0;\n\t\tthis.root = { x: 0, y: 0, width: width, height: height };\n\t\tfor (n = 0; n < len ; n++) {\n\t\t\tblock = blocks[n];\n\t\t\tif (node = this.findNode(this.root, block.width, block.height)) {\n\t\t\t\tfit = this.splitNode(node, block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfit = this.growNode(block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t}\n\t},\n\n\tfindNode: function(root, width, height) {\n\t\tif (root.used)\n\t\t\treturn this.findNode(root.right, width, height) || this.findNode(root.down, width, height);\n\t\telse if ((width <= root.width) && (height <= root.height))\n\t\t\treturn root;\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tsplitNode: function(node, width, height) {\n\t\tnode.used = true;\n\t\tnode.down  = { x: node.x,         y: node.y + height, width: node.width,         height: node.height - height };\n\t\tnode.right = { x: node.x + width, y: node.y,          width: node.width - width, height: height               };\n\t\treturn node;\n\t},\n\n\tgrowNode: function(width, height) {\n\t\tvar canGrowDown  = (width  <= this.root.width);\n\t\tvar canGrowRight = (height <= this.root.height);\n\n\t\tvar shouldGrowRight = canGrowRight && (this.root.height >= (this.root.width  + width )); // attempt to keep square-ish by growing right when height is much greater than width\n\t\tvar shouldGrowDown  = canGrowDown  && (this.root.width  >= (this.root.height + height)); // attempt to keep square-ish by growing down  when width  is much greater than height\n\n\t\tif (shouldGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (shouldGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse if (canGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (canGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse\n\t\t\treturn null; // need to ensure sensible root starting size to avoid this happening\n\t},\n\n\tgrowRight: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width + width,\n\t\t\theight: this.root.height,\n\t\t\tdown: this.root,\n\t\t\tright: { x: this.root.width, y: 0, width: width, height: this.root.height }\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tgrowDown: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width,\n\t\t\theight: this.root.height + height,\n\t\t\tdown:  { x: 0, y: this.root.height, width: this.root.width, height: height },\n\t\t\tright: this.root\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t}\n\n};\n\nmodule.exports = GrowingPacker;\n\n", "\"use strict\";\n\nvar GrowingPacker = require('./packer.growing.js');\n\nmodule.exports = function(items, options) {\n\toptions = options || {};\n\tvar packer = new GrowingPacker();\n\tvar inPlace = options.inPlace || false;\n\n\t// Clone the items.\n\tvar newItems = items.map(function(item) { return inPlace ? item : { width: item.width, height: item.height, item: item }; });\n\n\tnewItems = newItems.sort(function(a, b) {\n\t\t// TODO: check that each actually HAS a width and a height.\n\t\t// Sort based on the size (area) of each block.\n\t\treturn (b.width * b.height) - (a.width * a.height);\n\t});\n\n\tpacker.fit(newItems);\n\n\tvar w = newItems.reduce(function(curr, item) { return Math.max(curr, item.x + item.width); }, 0);\n\tvar h = newItems.reduce(function(curr, item) { return Math.max(curr, item.y + item.height); }, 0);\n\n\tvar ret = {\n\t\twidth: w,\n\t\theight: h\n\t};\n\n\tif (!inPlace) {\n\t\tret.items = newItems;\n\t}\n\n\treturn ret;\n};\n"],
  "mappings": ";;;;;AAAA;AAAA;AA2DA,QAAI,gBAAgB,WAAW;AAAA,IAAE;AAEjC,kBAAc,YAAY;AAAA,MAEzB,KAAK,SAAS,QAAQ;AACrB,YAAI,GAAG,MAAM,OAAO,MAAM,OAAO,QAAQ;AACzC,YAAI,QAAS,MAAM,IAAI,OAAO,CAAC,EAAE,QAAQ;AACzC,YAAI,SAAS,MAAM,IAAI,OAAO,CAAC,EAAE,SAAS;AAC1C,aAAK,OAAO,EAAE,GAAG,GAAG,GAAG,GAAG,OAAc,OAAe;AACvD,aAAK,IAAI,GAAG,IAAI,KAAM,KAAK;AAC1B,kBAAQ,OAAO,CAAC;AAChB,cAAI,OAAO,KAAK,SAAS,KAAK,MAAM,MAAM,OAAO,MAAM,MAAM,GAAG;AAC/D,kBAAM,KAAK,UAAU,MAAM,MAAM,OAAO,MAAM,MAAM;AACpD,kBAAM,IAAI,IAAI;AACd,kBAAM,IAAI,IAAI;AAAA,UACf,OACK;AACJ,kBAAM,KAAK,SAAS,MAAM,OAAO,MAAM,MAAM;AAC7C,kBAAM,IAAI,IAAI;AACd,kBAAM,IAAI,IAAI;AAAA,UACf;AAAA,QACD;AAAA,MACD;AAAA,MAEA,UAAU,SAAS,MAAM,OAAO,QAAQ;AACvC,YAAI,KAAK;AACR,iBAAO,KAAK,SAAS,KAAK,OAAO,OAAO,MAAM,KAAK,KAAK,SAAS,KAAK,MAAM,OAAO,MAAM;AAAA,iBAChF,SAAS,KAAK,SAAW,UAAU,KAAK;AACjD,iBAAO;AAAA;AAEP,iBAAO;AAAA,MACT;AAAA,MAEA,WAAW,SAAS,MAAM,OAAO,QAAQ;AACxC,aAAK,OAAO;AACZ,aAAK,OAAQ,EAAE,GAAG,KAAK,GAAW,GAAG,KAAK,IAAI,QAAQ,OAAO,KAAK,OAAe,QAAQ,KAAK,SAAS,OAAO;AAC9G,aAAK,QAAQ,EAAE,GAAG,KAAK,IAAI,OAAO,GAAG,KAAK,GAAY,OAAO,KAAK,QAAQ,OAAO,OAA6B;AAC9G,eAAO;AAAA,MACR;AAAA,MAEA,UAAU,SAAS,OAAO,QAAQ;AACjC,YAAI,cAAgB,SAAU,KAAK,KAAK;AACxC,YAAI,eAAgB,UAAU,KAAK,KAAK;AAExC,YAAI,kBAAkB,gBAAiB,KAAK,KAAK,UAAW,KAAK,KAAK,QAAS;AAC/E,YAAI,iBAAkB,eAAiB,KAAK,KAAK,SAAW,KAAK,KAAK,SAAS;AAE/E,YAAI;AACH,iBAAO,KAAK,UAAU,OAAO,MAAM;AAAA,iBAC3B;AACR,iBAAO,KAAK,SAAS,OAAO,MAAM;AAAA,iBAC1B;AACR,iBAAO,KAAK,UAAU,OAAO,MAAM;AAAA,iBAC3B;AACR,iBAAO,KAAK,SAAS,OAAO,MAAM;AAAA;AAElC,iBAAO;AAAA,MACT;AAAA,MAEA,WAAW,SAAS,OAAO,QAAQ;AAClC,aAAK,OAAO;AAAA,UACX,MAAM;AAAA,UACN,GAAG;AAAA,UACH,GAAG;AAAA,UACH,OAAO,KAAK,KAAK,QAAQ;AAAA,UACzB,QAAQ,KAAK,KAAK;AAAA,UAClB,MAAM,KAAK;AAAA,UACX,OAAO,EAAE,GAAG,KAAK,KAAK,OAAO,GAAG,GAAG,OAAc,QAAQ,KAAK,KAAK,OAAO;AAAA,QAC3E;AACA,YAAI;AACJ,YAAI,OAAO,KAAK,SAAS,KAAK,MAAM,OAAO,MAAM;AAChD,iBAAO,KAAK,UAAU,MAAM,OAAO,MAAM;AAAA;AAEzC,iBAAO;AAAA,MACT;AAAA,MAEA,UAAU,SAAS,OAAO,QAAQ;AACjC,aAAK,OAAO;AAAA,UACX,MAAM;AAAA,UACN,GAAG;AAAA,UACH,GAAG;AAAA,UACH,OAAO,KAAK,KAAK;AAAA,UACjB,QAAQ,KAAK,KAAK,SAAS;AAAA,UAC3B,MAAO,EAAE,GAAG,GAAG,GAAG,KAAK,KAAK,QAAQ,OAAO,KAAK,KAAK,OAAO,OAAe;AAAA,UAC3E,OAAO,KAAK;AAAA,QACb;AACA,YAAI;AACJ,YAAI,OAAO,KAAK,SAAS,KAAK,MAAM,OAAO,MAAM;AAChD,iBAAO,KAAK,UAAU,MAAM,OAAO,MAAM;AAAA;AAEzC,iBAAO;AAAA,MACT;AAAA,IAED;AAEA,WAAO,UAAU;AAAA;AAAA;;;AC1JjB;AAAA;AAEA,QAAI,gBAAgB;AAEpB,WAAO,UAAU,SAAS,OAAO,SAAS;AACzC,gBAAU,WAAW,CAAC;AACtB,UAAI,SAAS,IAAI,cAAc;AAC/B,UAAI,UAAU,QAAQ,WAAW;AAGjC,UAAI,WAAW,MAAM,IAAI,SAAS,MAAM;AAAE,eAAO,UAAU,OAAO,EAAE,OAAO,KAAK,OAAO,QAAQ,KAAK,QAAQ,KAAW;AAAA,MAAG,CAAC;AAE3H,iBAAW,SAAS,KAAK,SAAS,GAAG,GAAG;AAGvC,eAAQ,EAAE,QAAQ,EAAE,SAAW,EAAE,QAAQ,EAAE;AAAA,MAC5C,CAAC;AAED,aAAO,IAAI,QAAQ;AAEnB,UAAI,IAAI,SAAS,OAAO,SAAS,MAAM,MAAM;AAAE,eAAO,KAAK,IAAI,MAAM,KAAK,IAAI,KAAK,KAAK;AAAA,MAAG,GAAG,CAAC;AAC/F,UAAI,IAAI,SAAS,OAAO,SAAS,MAAM,MAAM;AAAE,eAAO,KAAK,IAAI,MAAM,KAAK,IAAI,KAAK,MAAM;AAAA,MAAG,GAAG,CAAC;AAEhG,UAAI,MAAM;AAAA,QACT,OAAO;AAAA,QACP,QAAQ;AAAA,MACT;AAEA,UAAI,CAAC,SAAS;AACb,YAAI,QAAQ;AAAA,MACb;AAEA,aAAO;AAAA,IACR;AAAA;AAAA;",
  "names": []
}
